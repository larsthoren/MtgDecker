@page "/game/{GameId}"
@rendermode InteractiveServer
@using MtgDecker.Engine
@using MtgDecker.Engine.Enums
@using MtgDecker.Web.Components.Pages.Game
@inject GameSessionManager SessionManager
@inject IDialogService DialogService
@inject NavigationManager Navigation
@implements IDisposable

<PageTitle>Game @GameId - MtgDecker</PageTitle>

@if (_session == null)
{
    <MudAlert Severity="Severity.Error" Class="ma-4">Game not found.</MudAlert>
}
else if (!_session.IsStarted && !_gameStarting)
{
    <MudContainer MaxWidth="MaxWidth.Small" Class="mt-4 text-center">
        <MudText Typo="Typo.h5">Starting game...</MudText>
        <MudProgressLinear Indeterminate="true" Class="mt-4" />
    </MudContainer>
}
else if (_session.State != null)
{
    <GameBoard State="_session.State"
               PlayerSeat="_playerSeat"
               Handler="_session.GetHandler(_playerSeat)"
               OnAction="HandleAction"
               OnSurrender="HandleSurrender"
               OnUndoTap="HandleUndoTap"
               IsGameOver="_session.IsGameOver"
               Winner="@_session.Winner"
               OnManaColorChosen="HandleManaColorChosen"
               OnAttackersChosen="HandleAttackersChosen"
               OnBlockersChosen="HandleBlockersChosen"
               OnBlockerOrderChosen="HandleBlockerOrderChosen"
               OnCardChosen="HandleCardChosen"
               OnRevealAcknowledged="HandleRevealAcknowledged"
               OnReorderSubmitted="HandleReorderSubmitted" />
}

@code {
    [Parameter] public string GameId { get; set; } = "";
    [SupplyParameterFromQuery(Name = "seat")] public int? SeatParam { get; set; }

    private GameSession? _session;
    private int _playerSeat;
    private bool _gameStarting;
    private bool _mulliganDialogOpen;
    private bool _componentRendered;
    private int _mulliganCount;

    protected override async Task OnInitializedAsync()
    {
        _session = SessionManager.GetSession(GameId);
        if (_session == null) return;

        _playerSeat = SeatParam ?? 1;

        _session.OnStateChanged += HandleStateChanged;

        if (!_session.IsStarted)
        {
            _gameStarting = true;
            await _session.StartAsync();
        }

        // Subscribe AFTER StartAsync â€” handlers are created inside StartAsync
        var handler = _session.GetHandler(_playerSeat);
        if (handler != null)
        {
            handler.OnWaitingForInput += HandleWaitingForInput;
        }
    }

    protected override async Task OnAfterRenderAsync(bool firstRender)
    {
        if (firstRender)
        {
            _componentRendered = true;
            // Check if handler is already waiting (event fired before we subscribed or before first render).
            // This recovers from circuit reconnects where OnWaitingForInput was missed.
            var handler = _session?.GetHandler(_playerSeat);
            if (handler?.IsWaitingForMulligan == true)
            {
                await ShowMulliganDialog(0);
            }
            else if (handler?.IsWaitingForInput == true)
            {
                HandleWaitingForInput();
            }
        }
    }

    private void HandleWaitingForInput()
    {
        if (!_componentRendered) return;

        var handler = _session!.GetHandler(_playerSeat);
        if (handler == null) return;

        if (handler.IsWaitingForMulligan)
        {
            _ = InvokeAsync(async () => await ShowMulliganDialog(_mulliganCount));
        }
        else if (handler.IsWaitingForAction)
        {
            // Check auto-pass for phase stops
            if (_session.State != null && handler.ShouldAutoPass(
                _session.State.CurrentPhase, _session.State.CombatStep, _session.State.StackCount == 0))
            {
                var localPlayer = _playerSeat == 1 ? _session.State.Player1 : _session.State.Player2;
                if (_session.State.PriorityPlayer == localPlayer)
                {
                    handler.SubmitAction(GameAction.Pass(localPlayer.Id));
                    return;
                }
            }
            InvokeAsync(StateHasChanged);
        }
        else if (handler.IsWaitingForManaColor)
        {
            InvokeAsync(StateHasChanged);
        }
        else if (handler.IsWaitingForAttackers || handler.IsWaitingForBlockers || handler.IsWaitingForBlockerOrder)
        {
            InvokeAsync(StateHasChanged);
        }
        else if (handler.IsWaitingForTarget)
        {
            InvokeAsync(StateHasChanged);
        }
        else if (handler.IsWaitingForCardChoice)
        {
            InvokeAsync(StateHasChanged);
        }
        else if (handler.IsWaitingForRevealAck)
        {
            InvokeAsync(StateHasChanged);
        }
        else if (handler.IsWaitingForDiscard)
        {
            InvokeAsync(StateHasChanged);
        }
        else if (handler.IsWaitingForSplit)
        {
            InvokeAsync(StateHasChanged);
        }
        else if (handler.IsWaitingForPileChoice)
        {
            InvokeAsync(StateHasChanged);
        }
        else if (handler.IsWaitingForReorder)
        {
            InvokeAsync(StateHasChanged);
        }
    }

    private async Task ShowMulliganDialog(int mulliganCount)
    {
        if (_mulliganDialogOpen) return;
        _mulliganDialogOpen = true;

        var handler = _session!.GetHandler(_playerSeat)!;
        var player = _playerSeat == 1 ? _session.State!.Player1 : _session.State!.Player2;

        var parameters = new DialogParameters<MulliganDialog>
        {
            { x => x.Hand, player.Hand.Cards },
            { x => x.MulliganCount, mulliganCount },
            { x => x.Handler, handler }
        };

        var options = new DialogOptions
        {
            CloseOnEscapeKey = false,
            MaxWidth = MaxWidth.Medium,
            BackdropClick = false
        };

        var dialog = await DialogService.ShowAsync<MulliganDialog>("Mulligan", parameters, options);
        await dialog.Result;
        _mulliganDialogOpen = false;
        _mulliganCount = mulliganCount + 1;
        // Next mulligan (if any) will be triggered by HandleWaitingForInput event
    }

    private void HandleManaColorChosen(ManaColor color)
    {
        var handler = _session?.GetHandler(_playerSeat);
        handler?.SubmitManaColor(color);
    }

    private void HandleAttackersChosen(IReadOnlyList<Guid> attackerIds)
    {
        var handler = _session?.GetHandler(_playerSeat);
        handler?.SubmitAttackers(attackerIds);
    }

    private void HandleBlockersChosen(Dictionary<Guid, Guid> assignments)
    {
        var handler = _session?.GetHandler(_playerSeat);
        handler?.SubmitBlockers(assignments);
    }

    private void HandleBlockerOrderChosen(IReadOnlyList<Guid> orderedBlockerIds)
    {
        var handler = _session?.GetHandler(_playerSeat);
        handler?.SubmitBlockerOrder(orderedBlockerIds);
    }

    private void HandleCardChosen(Guid? cardId)
    {
        var handler = _session?.GetHandler(_playerSeat);
        handler?.SubmitCardChoice(cardId);
    }

    private void HandleReorderSubmitted((IReadOnlyList<GameCard> ordered, bool shuffle) result)
    {
        var handler = _session?.GetHandler(_playerSeat);
        handler?.SubmitReorder(result.ordered, result.shuffle);
    }

    private void HandleRevealAcknowledged()
    {
        var handler = _session?.GetHandler(_playerSeat);
        handler?.AcknowledgeReveal();
    }

    private void HandleAction(GameAction action)
    {
        var handler = _session?.GetHandler(_playerSeat);
        handler?.SubmitAction(action);
    }

    private async Task HandleSurrender()
    {
        var result = await DialogService.ShowMessageBox(
            "Surrender",
            "Are you sure you want to surrender?",
            yesText: "Surrender", cancelText: "Cancel");
        if (result == true)
            _session?.Surrender(_playerSeat);
    }

    private void HandleUndoTap()
    {
        _session?.Undo(_playerSeat);
    }

    private void HandleStateChanged()
    {
        InvokeAsync(StateHasChanged);
    }

    public void Dispose()
    {
        if (_session != null)
        {
            _session.OnStateChanged -= HandleStateChanged;
            var handler = _session.GetHandler(_playerSeat);
            if (handler != null)
            {
                handler.OnWaitingForInput -= HandleWaitingForInput;
            }
            if (_session.IsGameOver)
            {
                SessionManager.RemoveSession(_session.GameId);
                _session.Dispose();
            }
        }
    }
}
