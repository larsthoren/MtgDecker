@using MtgDecker.Domain.Entities
@inject IMediator Mediator
@inject ISnackbar Snackbar

<MudDialog>
    <TitleContent>
        <MudText Typo="Typo.h6">@Card.Name</MudText>
    </TitleContent>
    <DialogContent>
        <MudGrid>
            <MudItem xs="12" sm="5">
                @if (!string.IsNullOrEmpty(Card.ImageUri))
                {
                    <MudImage Src="@Card.ImageUri" Alt="@Card.Name" ObjectFit="ObjectFit.Contain"
                              Fluid="true" Class="rounded-lg" />
                }
            </MudItem>
            <MudItem xs="12" sm="7">
                <MudStack Spacing="2">
                    <MudText Typo="Typo.subtitle1"><b>@Card.TypeLine</b></MudText>

                    @if (!string.IsNullOrEmpty(Card.ManaCost))
                    {
                        <MudText Typo="Typo.body2">Mana Cost: @Card.ManaCost (CMC: @Card.Cmc)</MudText>
                    }

                    @if (!string.IsNullOrEmpty(Card.OracleText))
                    {
                        <MudPaper Class="pa-3" Elevation="0" Outlined="true">
                            <MudText Typo="Typo.body2" Style="white-space: pre-wrap;">@Card.OracleText</MudText>
                        </MudPaper>
                    }

                    <MudDivider />

                    @* Ownership & Deck Info *@
                    <MudPaper Class="pa-3" Elevation="0" Outlined="true">
                        <MudStack Spacing="2">
                            <MudStack Row="true" AlignItems="AlignItems.Center" Spacing="1">
                                <MudIcon Icon="@Icons.Material.Filled.CollectionsBookmark" Size="Size.Small" />
                                <MudText Typo="Typo.body2"><b>Collection:</b></MudText>
                                <MudIconButton Icon="@Icons.Material.Filled.Remove" Size="Size.Small"
                                               Disabled="@(_collectionTotal <= 0)"
                                               OnClick="RemoveOneFromCollection" />
                                <MudText Typo="Typo.body1"><b>@_collectionTotal</b></MudText>
                                <MudIconButton Icon="@Icons.Material.Filled.Add" Size="Size.Small"
                                               Color="Color.Primary"
                                               OnClick="AddToCollection" />
                            </MudStack>
                            @if (_deckUsage.Count > 0)
                            {
                                <MudStack Row="true" AlignItems="AlignItems.Start">
                                    <MudIcon Icon="@Icons.Material.Filled.LibraryBooks" Size="Size.Small" Class="mt-1" />
                                    <MudStack Spacing="0">
                                        <MudText Typo="Typo.body2"><b>In Decks:</b></MudText>
                                        @foreach (var usage in _deckUsage)
                                        {
                                            <MudText Typo="Typo.body2" Class="ml-2">@usage.DeckName â€” @usage.Quantity copies</MudText>
                                        }
                                    </MudStack>
                                </MudStack>
                            }
                            else
                            {
                                <MudStack Row="true" AlignItems="AlignItems.Center">
                                    <MudIcon Icon="@Icons.Material.Filled.LibraryBooks" Size="Size.Small" />
                                    <MudText Typo="Typo.body2"><b>In Decks:</b> None</MudText>
                                </MudStack>
                            }
                        </MudStack>
                    </MudPaper>

                    @* Add to Deck *@
                    @if (_decks.Count > 0)
                    {
                        <MudStack Row="true" Spacing="2" AlignItems="AlignItems.Center">
                            <MudNumericField @bind-Value="_addToDeckQty" Label="Qty" Variant="Variant.Outlined"
                                             Min="1" Max="99" Style="width: 70px;" Margin="Margin.Dense" />
                            <MudMenu Label="Add to Deck" Variant="Variant.Filled" Color="Color.Secondary"
                                     Size="Size.Small" StartIcon="@Icons.Material.Filled.PlaylistAdd">
                                @foreach (var deck in _decks)
                                {
                                    <MudMenuItem OnClick="() => AddToDeck(deck)">@deck.Name (@deck.Format)</MudMenuItem>
                                }
                            </MudMenu>
                        </MudStack>
                    }

                    <MudDivider />

                    <MudText Typo="Typo.body2">
                        <b>Set:</b> @Card.SetName (@Card.SetCode.ToUpperInvariant())
                        @if (!string.IsNullOrEmpty(Card.CollectorNumber))
                        {
                            <span> #@Card.CollectorNumber</span>
                        }
                    </MudText>

                    <MudText Typo="Typo.body2"><b>Rarity:</b> @Card.Rarity</MudText>

                    @if (!string.IsNullOrEmpty(Card.Colors))
                    {
                        <MudText Typo="Typo.body2"><b>Colors:</b> @Card.Colors</MudText>
                    }

                    @if (Card.Legalities.Any())
                    {
                        <MudText Typo="Typo.subtitle2" Class="mt-2">Format Legality</MudText>
                        <MudSimpleTable Dense="true" Hover="true" Bordered="true">
                            <thead>
                                <tr>
                                    <th>Format</th>
                                    <th>Status</th>
                                </tr>
                            </thead>
                            <tbody>
                                @foreach (var legality in Card.Legalities.Where(l => _displayFormats.Contains(l.FormatName)))
                                {
                                    <tr>
                                        <td>@legality.FormatName</td>
                                        <td>
                                            <MudChip T="string" Size="Size.Small"
                                                     Color="@GetLegalityColor(legality.Status)">
                                                @legality.Status
                                            </MudChip>
                                        </td>
                                    </tr>
                                }
                            </tbody>
                        </MudSimpleTable>
                    }

                    @if (Card.HasMultipleFaces)
                    {
                        <MudText Typo="Typo.subtitle2" Class="mt-2">Card Faces</MudText>
                        @foreach (var face in Card.Faces)
                        {
                            <MudPaper Class="pa-2" Outlined="true">
                                <MudText Typo="Typo.body2"><b>@face.Name</b> - @face.TypeLine</MudText>
                                @if (!string.IsNullOrEmpty(face.OracleText))
                                {
                                    <MudText Typo="Typo.body2">@face.OracleText</MudText>
                                }
                                @if (!string.IsNullOrEmpty(face.Power))
                                {
                                    <MudText Typo="Typo.body2">@face.Power / @face.Toughness</MudText>
                                }
                            </MudPaper>
                        }
                    }
                </MudStack>
            </MudItem>
        </MudGrid>
    </DialogContent>
    <DialogActions>
        <MudButton OnClick="Cancel">Close</MudButton>
    </DialogActions>
</MudDialog>

@code {
    [CascadingParameter] private IMudDialogInstance MudDialog { get; set; } = default!;
    [Parameter] public Card Card { get; set; } = default!;

    private static readonly Guid UserId = Guid.Parse("00000000-0000-0000-0000-000000000001");

    private int _collectionTotal;
    private List<MtgDecker.Domain.Entities.CollectionEntry> _collectionEntries = new();
    private List<DeckUsageInfo> _deckUsage = new();
    private List<Deck> _decks = new();
    private int _addToDeckQty = 4;

    protected override async Task OnInitializedAsync()
    {
        await LoadOwnershipInfo();
    }

    private async Task LoadOwnershipInfo()
    {
        // Collection entries for this card
        var allEntries = await Mediator.Send(
            new MtgDecker.Application.Collection.SearchCollectionQuery(UserId));
        _collectionEntries = allEntries.Where(e => e.CardId == Card.Id).ToList();
        _collectionTotal = _collectionEntries.Sum(e => e.Quantity);

        // Deck usage
        _decks = await Mediator.Send(new MtgDecker.Application.Decks.ListDecksQuery(UserId));
        _deckUsage = new();
        foreach (var deck in _decks)
        {
            var fullDeck = await Mediator.Send(new MtgDecker.Application.Decks.GetDeckQuery(deck.Id));
            if (fullDeck == null) continue;
            var entry = fullDeck.Entries.FirstOrDefault(e => e.CardId == Card.Id);
            if (entry != null)
            {
                _deckUsage.Add(new DeckUsageInfo(fullDeck.Name, fullDeck.Format.ToString(), entry.Quantity));
            }
        }
    }

    private async Task AddToCollection()
    {
        try
        {
            if (_collectionEntries.Count > 0)
            {
                var entry = _collectionEntries[0];
                await Mediator.Send(new MtgDecker.Application.Collection.UpdateCollectionEntryCommand(
                    entry.Id, entry.Quantity + 1, entry.IsFoil, entry.Condition));
                entry.Quantity++;
            }
            else
            {
                var newEntry = await Mediator.Send(new MtgDecker.Application.Collection.AddToCollectionCommand(
                    UserId, Card.Id, 1, false, MtgDecker.Domain.Enums.CardCondition.NearMint));
                _collectionEntries.Add(newEntry);
            }
            _collectionTotal = _collectionEntries.Sum(e => e.Quantity);
            Snackbar.Add($"Added {Card.Name} to collection", Severity.Success);
        }
        catch (Exception ex)
        {
            Snackbar.Add($"Error: {ex.Message}", Severity.Error);
        }
    }

    private async Task RemoveOneFromCollection()
    {
        if (_collectionEntries.Count == 0) return;

        try
        {
            var entry = _collectionEntries[0];
            if (entry.Quantity > 1)
            {
                await Mediator.Send(new MtgDecker.Application.Collection.UpdateCollectionEntryCommand(
                    entry.Id, entry.Quantity - 1, entry.IsFoil, entry.Condition));
                entry.Quantity--;
            }
            else
            {
                await Mediator.Send(new MtgDecker.Application.Collection.RemoveFromCollectionCommand(entry.Id));
                _collectionEntries.Remove(entry);
            }
            _collectionTotal = _collectionEntries.Sum(e => e.Quantity);
            Snackbar.Add($"Removed {Card.Name} from collection", Severity.Info);
        }
        catch (Exception ex)
        {
            Snackbar.Add($"Error: {ex.Message}", Severity.Error);
        }
    }

    private async Task AddToDeck(Deck deck)
    {
        try
        {
            await Mediator.Send(new MtgDecker.Application.Decks.AddCardToDeckCommand(
                deck.Id, Card.Id, _addToDeckQty, MtgDecker.Domain.Enums.DeckCategory.MainDeck));

            var existing = _deckUsage.FirstOrDefault(d => d.DeckName == deck.Name);
            if (existing != null)
            {
                _deckUsage.Remove(existing);
                _deckUsage.Add(existing with { Quantity = existing.Quantity + _addToDeckQty });
            }
            else
            {
                _deckUsage.Add(new DeckUsageInfo(deck.Name, deck.Format.ToString(), _addToDeckQty));
            }

            Snackbar.Add($"Added {Card.Name} to {deck.Name}", Severity.Success);
        }
        catch (Exception ex)
        {
            Snackbar.Add(ex.Message, Severity.Error);
        }
    }

    private void Cancel() => MudDialog.Cancel();

    private Color GetLegalityColor(MtgDecker.Domain.Enums.LegalityStatus status) => status switch
    {
        MtgDecker.Domain.Enums.LegalityStatus.Legal => Color.Success,
        MtgDecker.Domain.Enums.LegalityStatus.Restricted => Color.Warning,
        MtgDecker.Domain.Enums.LegalityStatus.Banned => Color.Error,
        _ => Color.Default
    };

    private static readonly HashSet<string> _displayFormats = new(StringComparer.OrdinalIgnoreCase)
    {
        "legacy", "vintage", "modern", "premodern", "pauper", "oldschool", "commander"
    };

    private record DeckUsageInfo(string DeckName, string Format, int Quantity);
}
