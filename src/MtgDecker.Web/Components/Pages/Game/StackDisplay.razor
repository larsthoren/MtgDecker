@using MtgDecker.Engine
@using MtgDecker.Engine.Enums
@namespace MtgDecker.Web.Components.Pages.Game
@inject IJSRuntime JS

@if (Stack.Count > 0)
{
    <div class="stack-floating-box" @ref="_stackRef"
         style="@GetPositionStyle()">
        <div class="stack-header"
             @onmousedown="StartDrag"
             @onmousedown:preventDefault>
            <MudIcon Icon="@Icons.Material.Filled.Layers" Size="Size.Small" />
            <span>The Stack (@Stack.Count)</span>
            <span class="drag-hint">&#x2725;</span>
        </div>
        <div class="stack-cards">
            @for (int i = Stack.Count - 1; i >= 0; i--)
            {
                var item = Stack[i];
                var isTop = i == Stack.Count - 1;

                @if (item is StackObject spell)
                {
                    <div class="stack-card-entry @(IsTargeting ? "stack-targetable" : "") @(HighlightedStackItemIds?.Contains(spell.Card.Id) == true ? "stack-target-highlighted" : "")"
                         id="stack-item-@spell.Card.Id"
                         @onclick="() => HandleStackClick(spell.Card)"
                         @onmouseenter="async () => { await OnHoverStart.InvokeAsync(spell.Card.ImageUrl); await HandleStackItemHoverEnter(item); }"
                         @onmouseleave="async () => { await OnHoverEnd.InvokeAsync(); await HandleStackItemHoverLeave(); }">
                        <CardDisplay Name="@spell.Card.Name"
                                     ImageUrl="@spell.Card.ImageUrl"
                                     CardSize="100"
                                     Clickable="@IsTargeting"
                                     Power="@spell.Card.Power"
                                     Toughness="@spell.Card.Toughness" />
                        @if (spell.Targets.Count > 0)
                        {
                            <div class="stack-target-badge">targeted</div>
                        }
                        @if (isTop)
                        {
                            <div class="stack-resolving-badge">resolves next</div>
                        }
                    </div>
                }
                else if (item is TriggeredAbilityStackObject triggered)
                {
                    <div class="stack-card-entry @(IsTargeting ? "stack-targetable" : "") @(HighlightedStackItemIds?.Contains(triggered.Source.Id) == true ? "stack-target-highlighted" : "")"
                         id="stack-item-@triggered.Source.Id"
                         @onclick="() => HandleStackClick(triggered.Source)"
                         @onmouseenter="async () => { await OnHoverStart.InvokeAsync(triggered.Source.ImageUrl); await HandleStackItemHoverEnter(item); }"
                         @onmouseleave="async () => { await OnHoverEnd.InvokeAsync(); await HandleStackItemHoverLeave(); }">
                        <CardDisplay Name="@triggered.Source.Name"
                                     ImageUrl="@triggered.Source.ImageUrl"
                                     CardSize="100"
                                     Clickable="@IsTargeting" />
                        <div class="stack-trigger-badge">trigger</div>
                        @if (isTop)
                        {
                            <div class="stack-resolving-badge">resolves next</div>
                        }
                    </div>
                }
            }
        </div>
    </div>
}

@code {
    [Parameter] public List<IStackObject> Stack { get; set; } = new();
    [Parameter] public bool IsTargeting { get; set; }
    [Parameter] public EventCallback<GameCard> OnStackCardClicked { get; set; }
    [Parameter] public EventCallback<string?> OnHoverStart { get; set; }
    [Parameter] public EventCallback OnHoverEnd { get; set; }

    public record TargetHighlight(Guid CardId, Guid PlayerId, TargetZone Zone);
    public enum TargetZone { Battlefield, Stack, Player }
    public record StackTargetHoverInfo(string SourceElementId, List<TargetHighlight> Targets);

    [Parameter] public EventCallback<StackTargetHoverInfo?> OnTargetHover { get; set; }
    [Parameter] public HashSet<Guid>? HighlightedStackItemIds { get; set; }

    private ElementReference _stackRef;
    private double? _posX;
    private double? _posY;
    private DotNetObjectReference<StackDisplay>? _dotNetRef;

    private string GetPositionStyle()
    {
        if (_posX.HasValue && _posY.HasValue)
            return $"position: fixed; left: {_posX:F0}px; top: {_posY:F0}px; right: auto; transform: none;";
        return "";
    }

    private async Task StartDrag(MouseEventArgs e)
    {
        _dotNetRef ??= DotNetObjectReference.Create(this);
        await JS.InvokeVoidAsync("stackDrag.start", _stackRef, _dotNetRef, e.ClientX, e.ClientY);
    }

    [JSInvokable]
    public void OnDragMove(double x, double y)
    {
        _posX = x;
        _posY = y;
        InvokeAsync(StateHasChanged);
    }

    [JSInvokable]
    public void OnDragEnd()
    {
        InvokeAsync(StateHasChanged);
    }

    private async Task HandleStackClick(GameCard card)
    {
        if (IsTargeting)
            await OnStackCardClicked.InvokeAsync(card);
    }

    private async Task HandleStackItemHoverEnter(IStackObject item)
    {
        var targets = new List<TargetHighlight>();
        string sourceId;

        if (item is StackObject spell)
        {
            sourceId = $"stack-item-{spell.Card.Id}";
            foreach (var t in spell.Targets)
            {
                var zone = t.Zone == ZoneType.Stack ? TargetZone.Stack
                         : t.CardId == Guid.Empty ? TargetZone.Player
                         : TargetZone.Battlefield;
                targets.Add(new TargetHighlight(t.CardId, t.PlayerId, zone));
            }
        }
        else if (item is TriggeredAbilityStackObject triggered)
        {
            sourceId = $"stack-item-{triggered.Source.Id}";
            if (triggered.Target != null)
                targets.Add(new TargetHighlight(triggered.Target.Id, triggered.ControllerId, TargetZone.Battlefield));
            if (triggered.TargetPlayerId.HasValue)
                targets.Add(new TargetHighlight(Guid.Empty, triggered.TargetPlayerId.Value, TargetZone.Player));
        }
        else return;

        if (targets.Count > 0)
            await OnTargetHover.InvokeAsync(new StackTargetHoverInfo(sourceId, targets));
    }

    private async Task HandleStackItemHoverLeave()
    {
        await OnTargetHover.InvokeAsync(null);
    }

    public void Dispose()
    {
        _dotNetRef?.Dispose();
    }
}
