@using MtgDecker.Engine
@using MtgDecker.Engine.Enums
@using MtgDecker.Engine.Mana
@namespace MtgDecker.Web.Components.Pages.Game

<div class="game-board" tabindex="0" @ref="_boardRef">
    @if (IsGameOver)
    {
        <div class="game-over-overlay">
            <MudPaper Class="pa-6 text-center" Elevation="8">
                <MudText Typo="Typo.h4" Class="mb-2">Game Over</MudText>
                @if (Winner != null)
                {
                    <MudText Typo="Typo.h5" Color="Color.Secondary">@Winner wins!</MudText>
                }
                <MudButton Variant="Variant.Filled" Color="Color.Primary" Class="mt-4"
                           Href="/game/new">New Game</MudButton>
            </MudPaper>
        </div>
    }

    @* Row 1: Opponent info bar *@
    <div class="opponent-info-bar @(IsPlayerTargetable ? "targetable" : "")"
         @onclick="HandleOpponentInfoBarClick">
        <MudText Typo="Typo.subtitle2">@OpponentPlayer.Name</MudText>
        <MudChip T="string" Size="Size.Small" Color="Color.Error">@OpponentPlayer.Life HP</MudChip>
        <MudChip T="string" Size="Size.Small" Color="Color.Default">Hand: @OpponentPlayer.Hand.Cards.Count</MudChip>
        <MudChip T="string" Size="Size.Small" Color="Color.Default">Grave: @OpponentPlayer.Graveyard.Cards.Count</MudChip>
        <MudChip T="string" Size="Size.Small" Color="Color.Default">Exile: @OpponentPlayer.Exile.Cards.Count</MudChip>
        <MudChip T="string" Size="Size.Small" Color="Color.Default">Lib: @OpponentPlayer.Library.Count</MudChip>
        @if (OpponentPlayer.ManaPool?.Total > 0)
        {
            <div class="mana-pool-display">
                @foreach (var (color, symbol) in ManaSymbols)
                {
                    @if (OpponentPlayer.ManaPool[color] > 0)
                    {
                        <span class="mana-entry">
                            <img src="https://svgs.scryfall.io/card-symbols/@(symbol).svg"
                                 alt="@color" class="mana-symbol" />
                            <span class="mana-count">@OpponentPlayer.ManaPool[color]</span>
                        </span>
                    }
                }
            </div>
        }
        @if (State.ActivePlayer == OpponentPlayer)
        {
            <MudChip T="string" Size="Size.Small" Color="Color.Primary">Active</MudChip>
        }
    </div>

    @* Row 2: Opponent battlefield *@
    <div class="opponent-battlefield">
        <div class="battlefield-row lands-row">
            @foreach (var card in OpponentPlayer.Battlefield.Cards.Where(c => c.IsLand))
            {
                var attachments = GetAttachedCards(OpponentPlayer, card.Id);
                <div class="permanent-stack">
                    @foreach (var aura in attachments)
                    {
                        <div class="attached-aura attached-aura-sm">
                            <CardDisplay Name="@aura.Name"
                                         ImageUrl="@aura.ImageUrl"
                                         Tapped="@aura.IsTapped"
                                         CardSize="146"
                                         Clickable="@(IsTargetingMode)"
                                         EligibleTarget="@IsEligibleTarget(aura)"
                                         TargetingDimmed="@IsTargetingDimmed(aura)"
                                         OnClick="async () => await HandleOpponentCardClick(aura)" />
                        </div>
                    }
                    <div class="host-card">
                        <CardDisplay Name="@card.Name"
                                     ImageUrl="@card.ImageUrl"
                                     Tapped="@card.IsTapped"
                                     CardSize="146"
                                     Clickable="@(IsTargetingMode)"
                                     EligibleTarget="@IsEligibleTarget(card)"
                                     TargetingDimmed="@IsTargetingDimmed(card)"
                                     IsAttacking="@(State.Combat?.Attackers.Contains(card.Id) == true)"
                                     IsBlocking="@IsCardBlockingAnywhere(card.Id)"
                                     Power="@card.Power"
                                     Toughness="@card.Toughness"
                                     DamageMarked="@card.DamageMarked"
                                     OnClick="async () => await HandleOpponentCardClick(card)" />
                    </div>
                </div>
            }
        </div>
        <div class="battlefield-row nonlands-row">
            @foreach (var card in OpponentPlayer.Battlefield.Cards.Where(c => !c.IsLand && !c.AttachedTo.HasValue))
            {
                var attachments = GetAttachedCards(OpponentPlayer, card.Id);
                <div class="permanent-stack">
                    @foreach (var aura in attachments)
                    {
                        <div class="attached-aura attached-aura-sm">
                            <CardDisplay Name="@aura.Name"
                                         ImageUrl="@aura.ImageUrl"
                                         Tapped="@aura.IsTapped"
                                         CardSize="146"
                                         Clickable="@(IsTargetingMode)"
                                         EligibleTarget="@IsEligibleTarget(aura)"
                                         TargetingDimmed="@IsTargetingDimmed(aura)"
                                         OnClick="async () => await HandleOpponentCardClick(aura)" />
                        </div>
                    }
                    <div class="host-card">
                        <CardDisplay Name="@card.Name"
                                     ImageUrl="@card.ImageUrl"
                                     Tapped="@card.IsTapped"
                                     CardSize="146"
                                     Clickable="@(IsTargetingMode)"
                                     EligibleTarget="@IsEligibleTarget(card)"
                                     TargetingDimmed="@IsTargetingDimmed(card)"
                                     IsAttacking="@(State.Combat?.Attackers.Contains(card.Id) == true)"
                                     IsBlocking="@IsCardBlockingAnywhere(card.Id)"
                                     Power="@card.Power"
                                     Toughness="@card.Toughness"
                                     DamageMarked="@card.DamageMarked"
                                     SummoningSick="@(card.IsCreature && card.HasSummoningSickness(State.TurnNumber))"
                                     OnClick="async () => await HandleOpponentCardClick(card)" />
                    </div>
                </div>
            }
        </div>
        @if (OpponentPlayer.Battlefield.Cards.Count == 0)
        {
            <MudText Typo="Typo.caption" Class="empty-zone">Opponent Battlefield</MudText>
        }
    </div>

    @* Row 3: Phase bar *@
    <div class="phase-stack-row">
        @if (IsTargetingMode)
        {
            <div class="targeting-banner">
                <span>Choose target for @(Handler!.TargetingSpellName)</span>
                <MudButton Size="Size.Small" Variant="Variant.Outlined" Color="Color.Warning"
                           OnClick="HandleTargetCancel">Cancel</MudButton>
            </div>
        }
        <PhaseBar CurrentPhase="@State.CurrentPhase"
                  CurrentCombatStep="@State.CombatStep"
                  TurnNumber="@State.TurnNumber"
                  ActivePlayerName="@State.ActivePlayer.Name"
                  HasPriority="@HasPriority"
                  IsWaitingForCombat="@IsWaitingForCombat"
                  IsWaitingForAttackers="@(IsLocalActive && Handler?.IsWaitingForAttackers == true)"
                  IsWaitingForBlockers="@(IsLocalDefending && Handler?.IsWaitingForBlockers == true)"
                  StackCount="@State.StackCount"
                  StopSettings="@_phaseStops"
                  OnPass="HandlePassOrConfirm"
                  OnSkipCombat="HandleSkipCombat"
                  OnSurrender="() => OnSurrender.InvokeAsync()" />
    </div>

    @* Floating stack display (fixed position, right side) *@
    <StackDisplay Stack="@State.Stack"
                  IsTargeting="@(Handler?.IsWaitingForTarget == true)"
                  OnStackCardClicked="HandleStackCardTarget" />

    @* Row 4: Player battlefield *@
    <div class="player-battlefield">
        <div class="battlefield-row player-creatures">
            @foreach (var card in LocalPlayer.Battlefield.Cards.Where(c => !c.IsLand && !c.AttachedTo.HasValue))
            {
                var isEligibleAttacker = Handler?.IsWaitingForAttackers == true && IsLocalActive
                    && Handler?.EligibleAttackers?.Any(c => c.Id == card.Id) == true;
                var isEligibleBlocker = Handler?.IsWaitingForBlockers == true && IsLocalDefending
                    && Handler?.EligibleBlockers?.Any(c => c.Id == card.Id) == true;
                var attachments = GetAttachedCards(LocalPlayer, card.Id);
                <div class="permanent-stack">
                    @foreach (var aura in attachments)
                    {
                        <div class="attached-aura">
                            <CardDisplay Name="@aura.Name" ImageUrl="@aura.ImageUrl" Tapped="@aura.IsTapped"
                                         CardSize="146"
                                         Selected="@(_selectedCard?.Id == aura.Id)"
                                         EligibleTarget="@IsEligibleTarget(aura)"
                                         TargetingDimmed="@IsTargetingDimmed(aura)"
                                         Clickable="true"
                                         OnClick="async () => await HandleBattlefieldClick(aura, false, false)" />
                        </div>
                    }
                    <div class="host-card">
                        <CardDisplay Name="@card.Name" ImageUrl="@card.ImageUrl" Tapped="@card.IsTapped"
                                     Power="@card.Power" Toughness="@card.Toughness" DamageMarked="@card.DamageMarked"
                                     CardSize="146"
                                     Selected="@(_selectedCard?.Id == card.Id)"
                                     IsAttacking="@(_selectedAttackers.Contains(card.Id) || State.Combat?.Attackers.Contains(card.Id) == true)"
                                     IsBlocking="@(_blockerAssignments.ContainsKey(card.Id) || IsCardBlockingAnywhere(card.Id))"
                                     Eligible="@(isEligibleAttacker || isEligibleBlocker)"
                                     EligibleTarget="@IsEligibleTarget(card)"
                                     TargetingDimmed="@IsTargetingDimmed(card)"
                                     SummoningSick="@(card.IsCreature && card.HasSummoningSickness(State.TurnNumber))"
                                     Clickable="true"
                                     OnClick="async () => await HandleBattlefieldClick(card, isEligibleAttacker, isEligibleBlocker)" />
                    </div>
                </div>
            }
        </div>
        <div class="battlefield-row player-lands">
            @foreach (var card in LocalPlayer.Battlefield.Cards.Where(c => c.IsLand))
            {
                var isUndoCandidate = card.IsTapped
                    && LocalPlayer.ActionHistory.Count > 0
                    && LocalPlayer.ActionHistory.Peek().Type == ActionType.TapCard
                    && LocalPlayer.ActionHistory.Peek().CardId == card.Id
                    && LocalPlayer.PendingManaTaps.Contains(card.Id);
                var attachments = GetAttachedCards(LocalPlayer, card.Id);
                <div class="permanent-stack">
                    @foreach (var aura in attachments)
                    {
                        <div class="attached-aura">
                            <CardDisplay Name="@aura.Name" ImageUrl="@aura.ImageUrl" Tapped="@aura.IsTapped"
                                         CardSize="146"
                                         Selected="@(_selectedCard?.Id == aura.Id)"
                                         EligibleTarget="@IsEligibleTarget(aura)"
                                         TargetingDimmed="@IsTargetingDimmed(aura)"
                                         Clickable="true"
                                         OnClick="async () => await HandleBattlefieldClick(aura, false, false)" />
                        </div>
                    }
                    <div class="land-wrapper host-card">
                        <CardDisplay Name="@card.Name" ImageUrl="@card.ImageUrl" Tapped="@card.IsTapped"
                                     CardSize="146"
                                     Selected="@(_selectedCard?.Id == card.Id)"
                                     EligibleTarget="@IsEligibleTarget(card)"
                                     TargetingDimmed="@IsTargetingDimmed(card)"
                                     Clickable="true"
                                     OnClick="async () => await HandleLandClick(card)" />
                        @if (isUndoCandidate)
                        {
                            <button class="untap-affordance" @onclick="HandleUntapLand"
                                    @onclick:stopPropagation="true"
                                    title="Untap (unspent mana)">
                                &#x21B6;
                            </button>
                        }
                    </div>
                </div>
            }
        </div>
        @if (LocalPlayer.Battlefield.Cards.Count == 0)
        {
            <MudText Typo="Typo.caption" Class="empty-zone">Battlefield</MudText>
        }
    </div>

    @* Row 5: Player info bar *@
    <div class="player-info-bar @(IsPlayerTargetable ? "targetable" : "")"
         @onclick="HandlePlayerInfoBarClick">
        <MudText Typo="Typo.subtitle2">@LocalPlayer.Name</MudText>
        <MudChip T="string" Size="Size.Small" Color="Color.Error">@LocalPlayer.Life HP</MudChip>
        <MudChip T="string" Size="Size.Small" Color="Color.Default">Hand: @LocalPlayer.Hand.Cards.Count</MudChip>
        @if (IsLocalActive)
        {
            <MudChip T="string" Size="Size.Small" Color="Color.Primary">Active</MudChip>
        }
        @if (LocalPlayer.ManaPool?.Total > 0)
        {
            <div class="mana-pool-display">
                @foreach (var (color, symbol) in ManaSymbols)
                {
                    @if (LocalPlayer.ManaPool[color] > 0)
                    {
                        <span class="mana-entry">
                            <img src="https://svgs.scryfall.io/card-symbols/@(symbol).svg"
                                 alt="@color" class="mana-symbol" />
                            <span class="mana-count">@LocalPlayer.ManaPool[color]</span>
                        </span>
                    }
                }
            </div>
        }
        <MudChip T="string" Size="Size.Small" Color="Color.Default">Grave: @LocalPlayer.Graveyard.Cards.Count</MudChip>
        <MudChip T="string" Size="Size.Small" Color="Color.Default">Exile: @LocalPlayer.Exile.Cards.Count</MudChip>
        <MudChip T="string" Size="Size.Small" Color="Color.Default">Lib: @LocalPlayer.Library.Count</MudChip>
    </div>

    @* Row 6: Player hand *@
    <div class="player-hand">
        @foreach (var card in LocalPlayer.Hand.Cards)
        {
            <CardDisplay Name="@card.Name" ImageUrl="@card.ImageUrl"
                         CardSize="146"
                         Selected="@(_selectedCard?.Id == card.Id)"
                         Clickable="true"
                         OnClick="async () => await HandleHandClick(card)" />
        }
        @if (LocalPlayer.Hand.Cards.Count == 0)
        {
            <MudText Typo="Typo.caption" Class="empty-zone">Hand (empty)</MudText>
        }
    </div>

    @* Prompt overlays *@

    @* Action Menu (appears when card is selected) *@
    @if (_selectedCard != null && HasPriority)
    {
        <div class="prompt-overlay">
            <ActionMenu Visible="true"
                        CardName="@_selectedCard.Name"
                        CurrentZone="_selectedZone"
                        IsOwnCard="true"
                        IsTapped="@_selectedCard.IsTapped"
                        HasTapAbility="@(_selectedCard.IsLand || _selectedCard.ManaAbility != null)"
                        HasActivatedAbility="@HasActivatedAbility(_selectedCard)"
                        OnPlay="HandlePlay"
                        OnTapToggle="HandleTapToggle"
                        OnActivate="HandleActivate"
                        OnClose="ClearSelection" />
        </div>
    }

    @* Pending cast — tap lands to pay mana cost *@
    @if (_pendingCastCard?.ManaCost != null)
    {
        <div class="prompt-overlay">
            <MudPaper Class="pa-3" Elevation="8" Style="min-width: 220px;">
                <MudText Typo="Typo.subtitle2" Class="mb-1">Cast @_pendingCastCard.Name</MudText>
                <div style="display: flex; align-items: center; gap: 6px; margin-bottom: 8px;">
                    <MudText Typo="Typo.body2">Tap lands to pay</MudText>
                    @foreach (var (color, symbol) in ManaSymbols)
                    {
                        @if (_pendingCastCard.ManaCost.ColorRequirements.TryGetValue(color, out var needed))
                        {
                            @for (int i = 0; i < needed; i++)
                            {
                                <img src="https://svgs.scryfall.io/card-symbols/@(symbol).svg"
                                     alt="@color" style="width: 22px; height: 22px;" />
                            }
                        }
                    }
                    @if (_pendingCastCard.ManaCost.GenericCost > 0)
                    {
                        <img src="https://svgs.scryfall.io/card-symbols/@(_pendingCastCard.ManaCost.GenericCost).svg"
                             alt="generic" style="width: 22px; height: 22px;" />
                    }
                </div>
                <MudButton Size="Size.Small" Variant="Variant.Text" Color="Color.Default"
                           OnClick="CancelPendingCast">Cancel</MudButton>
            </MudPaper>
        </div>
    }

    @* Blocker ordering prompt *@
    @if (Handler?.IsWaitingForBlockerOrder == true && IsLocalActive && Handler?.BlockersToOrder != null)
    {
        <div class="prompt-overlay">
            <MudPaper Class="pa-3" Elevation="8">
                <MudText Typo="Typo.subtitle1">Order Blockers</MudText>
                <MudText Typo="Typo.body2" Class="mb-2">Click blockers in damage order.</MudText>
                <div class="blocker-order-list" style="display: flex; flex-wrap: wrap; gap: 4px;">
                    @foreach (var blocker in Handler.BlockersToOrder)
                    {
                        var orderIndex = _blockerOrder.IndexOf(blocker.Id);
                        <MudChip T="string" Color="@(orderIndex >= 0 ? Color.Primary : Color.Default)"
                                 OnClick="@(() => AddToBlockerOrder(blocker.Id))">
                            @if (orderIndex >= 0) { @($"#{orderIndex + 1} ") }
                            @blocker.Name (@blocker.Power/@blocker.Toughness)
                        </MudChip>
                    }
                </div>
                <MudButton Variant="Variant.Filled" Color="Color.Primary" Class="mt-2"
                           OnClick="ConfirmBlockerOrder">Confirm Order</MudButton>
            </MudPaper>
        </div>
    }

    @* Mana color picker *@
    @if (IsWaitingForManaColor && ManaColorOptions != null)
    {
        <div class="prompt-overlay">
            <MudPaper Class="pa-2" Elevation="8">
                <MudText Typo="Typo.caption" Class="mb-1">Choose mana color:</MudText>
                <div style="display: flex; gap: 8px;">
                    @foreach (var color in ManaColorOptions)
                    {
                        var symbol = ManaSymbols.First(m => m.color == color).symbol;
                        <MudIconButton OnClick="async () => await OnManaColorChosen.InvokeAsync(color)">
                            <img src="https://svgs.scryfall.io/card-symbols/@(symbol).svg"
                                 alt="@color" style="width: 32px; height: 32px;" />
                        </MudIconButton>
                    }
                </div>
            </MudPaper>
        </div>
    }

    @* Card choice prompt (tutor) *@
    @if (Handler?.IsWaitingForCardChoice == true && Handler?.CardChoiceOptions != null)
    {
        <div class="prompt-overlay">
            <MudPaper Class="pa-3" Elevation="8">
                <MudText Typo="Typo.body2" Class="mb-2">@(Handler.CardChoicePrompt)</MudText>
                <div style="display: flex; flex-wrap: wrap; gap: 4px;">
                    @foreach (var card in Handler.CardChoiceOptions)
                    {
                        var isSelected = _selectedChoiceId == card.Id;
                        <div style="cursor: pointer; @(isSelected ? "outline: 3px solid #C69B3C; border-radius: 8px;" : "")"
                             @onclick="() => ToggleCardChoice(card.Id)">
                            <CardDisplay ImageUrl="@card.ImageUrl" Name="@card.Name" Clickable="true" />
                        </div>
                    }
                </div>
                <div style="display: flex; gap: 8px; margin-top: 8px;">
                    @if (Handler.CardChoiceOptional)
                    {
                        <MudButton Size="Size.Small" Variant="Variant.Outlined" OnClick="() => SubmitCardChoice(null)">Skip</MudButton>
                    }
                    <MudButton Size="Size.Small" Variant="Variant.Filled" Color="Color.Primary"
                               Disabled="@(_selectedChoiceId == null)" OnClick="() => SubmitCardChoice(_selectedChoiceId)">Choose</MudButton>
                </div>
            </MudPaper>
        </div>
    }

    @* Reveal cards prompt *@
    @if (Handler?.IsWaitingForRevealAck == true && Handler?.RevealedCards != null)
    {
        <div class="prompt-overlay">
            <MudPaper Class="pa-3" Elevation="8">
                <MudText Typo="Typo.body2" Class="mb-2">@(Handler.RevealPrompt)</MudText>
                <div style="display: flex; flex-wrap: wrap; gap: 4px;">
                    @foreach (var card in Handler.RevealedCards)
                    {
                        var isKept = Handler.KeptCards?.Any(k => k.Id == card.Id) == true;
                        <div>
                            <CardDisplay ImageUrl="@card.ImageUrl" Name="@card.Name" Clickable="false" />
                            @if (isKept)
                            {
                                <MudChip T="string" Size="Size.Small" Color="Color.Success">To Hand</MudChip>
                            }
                        </div>
                    }
                </div>
                <MudButton Size="Size.Small" Variant="Variant.Filled" Color="Color.Primary" Class="mt-2"
                           OnClick="() => OnRevealAcknowledged.InvokeAsync()">OK</MudButton>
            </MudPaper>
        </div>
    }

    @* Blocker assignment prompt (when blocker selected, show attackers to assign to) *@
    @if (Handler?.IsWaitingForBlockers == true && IsLocalDefending && _selectedBlocker != null && Handler?.CurrentAttackers != null)
    {
        <div class="prompt-overlay">
            <MudPaper Class="pa-2" Elevation="8">
                <MudText Typo="Typo.body2" Class="mb-1">Click an attacker to assign block:</MudText>
                @foreach (var attacker in Handler.CurrentAttackers)
                {
                    <MudChip T="string" Color="Color.Error" Class="target-highlight"
                             OnClick="@(() => AssignBlockerToAttacker(attacker.Id))">
                        @attacker.Name (@attacker.Power/@attacker.Toughness)
                    </MudChip>
                }
            </MudPaper>
        </div>
    }

    @* Log toggle button *@
    <MudButton StartIcon="@Icons.Material.Filled.Article" Size="Size.Small"
               Variant="Variant.Outlined" Class="log-toggle-btn" OnClick="ToggleLog" Title="Toggle Game Log">Log</MudButton>

    @* Log overlay *@
    @if (_showLog)
    {
        <div class="log-overlay" @onclick="ToggleLog">
            <div class="log-panel" @onclick:stopPropagation>
                <GameLogPanel GameLog="@State.GameLog" />
            </div>
        </div>
    }
</div>

@code {
    [Parameter] public GameState State { get; set; } = default!;
    [Parameter] public int PlayerSeat { get; set; }
    [Parameter] public InteractiveDecisionHandler? Handler { get; set; }
    [Parameter] public EventCallback<GameAction> OnAction { get; set; }
    [Parameter] public EventCallback OnSurrender { get; set; }
    [Parameter] public EventCallback OnUndoTap { get; set; }
    [Parameter] public bool IsGameOver { get; set; }
    [Parameter] public string? Winner { get; set; }
    [Parameter] public EventCallback<ManaColor> OnManaColorChosen { get; set; }
    [Parameter] public EventCallback<IReadOnlyList<Guid>> OnAttackersChosen { get; set; }
    [Parameter] public EventCallback<Dictionary<Guid, Guid>> OnBlockersChosen { get; set; }
    [Parameter] public EventCallback<IReadOnlyList<Guid>> OnBlockerOrderChosen { get; set; }
    [Parameter] public EventCallback<Guid?> OnCardChosen { get; set; }
    [Parameter] public EventCallback OnRevealAcknowledged { get; set; }

    private ElementReference _boardRef;
    private PhaseStopSettings _phaseStops = new();
    private bool _showLog = false;

    // Card selection state
    private GameCard? _selectedCard;
    private ZoneType _selectedZone;

    // Combat selection state
    private HashSet<Guid> _selectedAttackers = new();
    private Dictionary<Guid, Guid> _blockerAssignments = new(); // blockerId -> attackerId
    private Guid? _selectedBlocker;
    private List<Guid> _blockerOrder = new();

    // Card choice state
    private Guid? _selectedChoiceId;

    // Pending cast state (waiting for player to tap lands)
    private GameCard? _pendingCastCard;

    private Player LocalPlayer => PlayerSeat == 1 ? State.Player1 : State.Player2;
    private Player OpponentPlayer => PlayerSeat == 1 ? State.Player2 : State.Player1;
    private int OpponentSeat => PlayerSeat == 1 ? 2 : 1;
    private bool HasPriority => Handler?.IsWaitingForAction == true;
    private bool IsWaitingForManaColor => Handler?.IsWaitingForManaColor == true;
    private IReadOnlyList<ManaColor>? ManaColorOptions => Handler?.ManaColorOptions;
    private bool IsLocalActive => State.ActivePlayer == LocalPlayer;
    private bool IsLocalDefending => State.ActivePlayer == OpponentPlayer;
    private bool IsWaitingForCombat =>
        Handler?.IsWaitingForAttackers == true ||
        Handler?.IsWaitingForBlockers == true ||
        Handler?.IsWaitingForBlockerOrder == true;
    private bool IsWaitingForCardChoice => Handler?.IsWaitingForCardChoice == true;
    private bool IsWaitingForRevealAck => Handler?.IsWaitingForRevealAck == true;

    private void ToggleLog() => _showLog = !_showLog;

    // --- Targeting helpers ---
    private bool IsTargetingMode => Handler?.IsWaitingForTarget == true && Handler?.EligibleTargets != null;

    private bool IsEligibleTarget(GameCard card) =>
        IsTargetingMode && Handler!.EligibleTargets!.Any(t => t.Id == card.Id);

    private bool IsPlayerTargetable =>
        IsTargetingMode && Handler!.EligibleTargets!.Any(t => t.Id == Guid.Empty);

    private bool IsTargetingDimmed(GameCard card) =>
        IsTargetingMode && !IsEligibleTarget(card);

    protected override async Task OnAfterRenderAsync(bool firstRender)
    {
        if (firstRender)
        {
            await _boardRef.FocusAsync();
        }
    }

    protected override async Task OnParametersSetAsync()
    {
        // When state updates arrive (e.g. after a land tap), check if a pending
        // cast can now be completed with the updated mana pool.
        await TryCompletePendingCast();
    }

    // --- Pass / Combat confirm via PhaseBar ---

    private async Task HandlePassOrConfirm()
    {
        if (Handler?.IsWaitingForAttackers == true && IsLocalActive)
        {
            await OnAttackersChosen.InvokeAsync(_selectedAttackers.ToList());
            _selectedAttackers.Clear();
        }
        else if (Handler?.IsWaitingForBlockers == true && IsLocalDefending)
        {
            await OnBlockersChosen.InvokeAsync(new Dictionary<Guid, Guid>(_blockerAssignments));
            _blockerAssignments.Clear();
            _selectedBlocker = null;
        }
        else
        {
            await OnAction.InvokeAsync(GameAction.Pass(LocalPlayer.Id));
        }
    }

    private async Task HandleSkipCombat()
    {
        if (Handler?.IsWaitingForAttackers == true)
        {
            await OnAttackersChosen.InvokeAsync(new List<Guid>());
            _selectedAttackers.Clear();
        }
        else if (Handler?.IsWaitingForBlockers == true)
        {
            await OnBlockersChosen.InvokeAsync(new Dictionary<Guid, Guid>());
            _blockerAssignments.Clear();
        }
    }

    // --- Battlefield interaction ---

    private async Task HandleBattlefieldClick(GameCard card, bool isEligibleAttacker, bool isEligibleBlocker)
    {
        // If we're targeting, submit target
        if (Handler?.IsWaitingForTarget == true)
        {
            Handler.SubmitTarget(new TargetInfo(card.Id, LocalPlayer.Id, ZoneType.Battlefield));
            return;
        }

        if (isEligibleAttacker)
        {
            ToggleAttacker(card.Id);
            return;
        }

        if (isEligibleBlocker)
        {
            SelectBlocker(card.Id);
            return;
        }

        await SelectCard(card, ZoneType.Battlefield);
    }

    private async Task HandleLandClick(GameCard card)
    {
        // If we're targeting, submit target
        if (Handler?.IsWaitingForTarget == true)
        {
            Handler.SubmitTarget(new TargetInfo(card.Id, LocalPlayer.Id, ZoneType.Battlefield));
            return;
        }

        // Untapped lands with mana ability: tap for mana immediately
        if (!card.IsTapped && card.ManaAbility != null)
        {
            await OnAction.InvokeAsync(GameAction.TapCard(LocalPlayer.Id, card.Id));
            ClearSelection();
            await TryCompletePendingCast();
            return;
        }

        // Untapped fetch lands: activate fetch ability
        if (!card.IsTapped && card.FetchAbility != null)
        {
            await OnAction.InvokeAsync(GameAction.ActivateFetch(LocalPlayer.Id, card.Id));
            ClearSelection();
            return;
        }

        await SelectCard(card, ZoneType.Battlefield);
    }

    private async Task HandleHandClick(GameCard card)
    {
        if (!HasPriority) return;

        // If we're targeting, submit target
        if (Handler?.IsWaitingForTarget == true)
        {
            Handler.SubmitTarget(new TargetInfo(card.Id, LocalPlayer.Id, ZoneType.Hand));
            return;
        }

        await SelectCard(card, ZoneType.Hand);
    }

    private Task SelectCard(GameCard card, ZoneType zone)
    {
        if (_selectedCard?.Id == card.Id)
        {
            ClearSelection();
            return Task.CompletedTask;
        }
        _selectedCard = card;
        _selectedZone = zone;
        return Task.CompletedTask;
    }

    private void ClearSelection() { _selectedCard = null; }

    // --- Combat: Attacker selection ---

    private void ToggleAttacker(Guid cardId)
    {
        if (_selectedAttackers.Contains(cardId))
            _selectedAttackers.Remove(cardId);
        else
            _selectedAttackers.Add(cardId);
    }

    // --- Combat: Blocker selection ---

    private void SelectBlocker(Guid cardId)
    {
        if (_blockerAssignments.ContainsKey(cardId))
        {
            _blockerAssignments.Remove(cardId);
            _selectedBlocker = null;
        }
        else
        {
            _selectedBlocker = cardId;
        }
    }

    private void AssignBlockerToAttacker(Guid attackerId)
    {
        if (_selectedBlocker.HasValue)
        {
            _blockerAssignments[_selectedBlocker.Value] = attackerId;
            _selectedBlocker = null;
        }
    }

    // --- Combat: Blocker ordering ---

    private void AddToBlockerOrder(Guid blockerId)
    {
        if (!_blockerOrder.Contains(blockerId))
            _blockerOrder.Add(blockerId);
    }

    private async Task ConfirmBlockerOrder()
    {
        if (Handler?.BlockersToOrder != null)
        {
            foreach (var b in Handler.BlockersToOrder)
            {
                if (!_blockerOrder.Contains(b.Id))
                    _blockerOrder.Add(b.Id);
            }
        }
        await OnBlockerOrderChosen.InvokeAsync(_blockerOrder.ToList());
        _blockerOrder.Clear();
    }

    // --- Card actions (from ActionMenu) ---

    private async Task HandlePlay()
    {
        if (_selectedCard == null) return;
        if (_selectedCard.IsLand)
        {
            await OnAction.InvokeAsync(GameAction.PlayCard(LocalPlayer.Id, _selectedCard.Id));
            ClearSelection();
            return;
        }

        // Non-land: check if we can pay the mana cost
        if (_selectedCard.ManaCost != null && !LocalPlayer.ManaPool.CanPay(_selectedCard.ManaCost))
        {
            // Enter pending cast mode — player taps lands to pay
            _pendingCastCard = _selectedCard;
            ClearSelection();
            return;
        }

        await OnAction.InvokeAsync(GameAction.CastSpell(LocalPlayer.Id, _selectedCard.Id));
        ClearSelection();
    }

    private async Task HandleTapToggle()
    {
        if (_selectedCard == null) return;
        await OnAction.InvokeAsync(GameAction.TapCard(LocalPlayer.Id, _selectedCard.Id));
        ClearSelection();
        await TryCompletePendingCast();
    }

    // --- Board-based targeting ---

    private void HandleOpponentInfoBarClick()
    {
        if (IsPlayerTargetable)
            Handler?.SubmitTarget(new TargetInfo(Guid.Empty, OpponentPlayer.Id, ZoneType.None));
    }

    private void HandlePlayerInfoBarClick()
    {
        if (IsPlayerTargetable)
            Handler?.SubmitTarget(new TargetInfo(Guid.Empty, LocalPlayer.Id, ZoneType.None));
    }

    private void HandleTargetCancel()
    {
        Handler?.CancelTarget();
    }

    private void HandleStackCardTarget(GameCard card)
    {
        if (Handler?.IsWaitingForTarget == true)
        {
            var ownerId = LocalPlayer.Id; // Stack spells use controller from stack context
            Handler.SubmitTarget(new TargetInfo(card.Id, ownerId, ZoneType.Stack));
        }
    }

    private Task HandleOpponentCardClick(GameCard card)
    {
        if (Handler?.IsWaitingForTarget == true)
            Handler.SubmitTarget(new TargetInfo(card.Id, OpponentPlayer.Id, ZoneType.Battlefield));
        return Task.CompletedTask;
    }

    // --- Card choice (tutor) ---

    private void ToggleCardChoice(Guid cardId) => _selectedChoiceId = _selectedChoiceId == cardId ? null : cardId;

    private async Task SubmitCardChoice(Guid? cardId)
    {
        _selectedChoiceId = null;
        await OnCardChosen.InvokeAsync(cardId);
    }

    // --- Pending cast (tap lands to pay) ---

    private async Task TryCompletePendingCast()
    {
        if (_pendingCastCard == null) return;
        if (_pendingCastCard.ManaCost == null) return;
        if (!LocalPlayer.ManaPool.CanPay(_pendingCastCard.ManaCost)) return;
        // Only dispatch when the handler is ready to receive the action;
        // OnParametersSetAsync may fire before the engine creates a new action TCS.
        if (Handler?.IsWaitingForAction != true) return;

        var card = _pendingCastCard;
        _pendingCastCard = null;
        await OnAction.InvokeAsync(GameAction.CastSpell(LocalPlayer.Id, card.Id));
    }

    private void CancelPendingCast() => _pendingCastCard = null;

    // --- Untap (pending mana) ---

    private async Task HandleUntapLand()
    {
        await OnUndoTap.InvokeAsync();
    }

    // --- Activated abilities ---

    private bool HasActivatedAbility(GameCard card) =>
        CardDefinitions.TryGet(card.Name, out var def) && def.ActivatedAbility != null;

    private async Task HandleActivate()
    {
        if (_selectedCard == null) return;
        await OnAction.InvokeAsync(GameAction.ActivateAbility(LocalPlayer.Id, _selectedCard.Id));
        ClearSelection();
    }

    // --- Helpers ---

    private bool IsCardBlockingAnywhere(Guid cardId) =>
        State.Combat?.Attackers.Any(a => State.Combat.GetBlockers(a).Contains(cardId)) == true;

    private IReadOnlyList<GameCard> GetAttachedCards(Player player, Guid hostId) =>
        player.Battlefield.Cards.Where(c => c.AttachedTo == hostId).ToList();

    private static readonly (ManaColor color, string symbol)[] ManaSymbols =
    [
        (ManaColor.White, "W"), (ManaColor.Blue, "U"), (ManaColor.Black, "B"),
        (ManaColor.Red, "R"), (ManaColor.Green, "G"), (ManaColor.Colorless, "C")
    ];
}
