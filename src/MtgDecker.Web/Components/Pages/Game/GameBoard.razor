@using MtgDecker.Engine
@using MtgDecker.Engine.Enums
@using MtgDecker.Engine.Mana
@namespace MtgDecker.Web.Components.Pages.Game

<div class="game-board" tabindex="0" @ref="_boardRef" @onkeydown="HandleKeyDown">
    @if (IsGameOver)
    {
        <div class="game-over-overlay">
            <MudPaper Class="pa-6 text-center" Elevation="8">
                <MudText Typo="Typo.h4" Class="mb-2">Game Over</MudText>
                @if (Winner != null)
                {
                    <MudText Typo="Typo.h5" Color="Color.Secondary">@Winner wins!</MudText>
                }
                <MudButton Variant="Variant.Filled" Color="Color.Primary" Class="mt-4"
                           Href="/game/new">New Game</MudButton>
            </MudPaper>
        </div>
    }

    @* Row 1: Opponent info bar *@
    <div class="opponent-info-bar">
        <MudText Typo="Typo.subtitle2">@OpponentPlayer.Name</MudText>
        <MudChip T="string" Size="Size.Small" Color="Color.Error">@OpponentPlayer.Life HP</MudChip>
        <MudChip T="string" Size="Size.Small" Color="Color.Default">Hand: @OpponentPlayer.Hand.Cards.Count</MudChip>
        <MudChip T="string" Size="Size.Small" Color="Color.Default">Grave: @OpponentPlayer.Graveyard.Cards.Count</MudChip>
        <MudChip T="string" Size="Size.Small" Color="Color.Default">Exile: @OpponentPlayer.Exile.Cards.Count</MudChip>
        <MudChip T="string" Size="Size.Small" Color="Color.Default">Lib: @OpponentPlayer.Library.Count</MudChip>
        @if (OpponentPlayer.ManaPool?.Total > 0)
        {
            <div class="mana-pool-display">
                @foreach (var (color, symbol) in ManaSymbols)
                {
                    @if (OpponentPlayer.ManaPool[color] > 0)
                    {
                        <span class="mana-entry">
                            <img src="https://svgs.scryfall.io/card-symbols/@(symbol).svg"
                                 alt="@color" class="mana-symbol" />
                            <span class="mana-count">@OpponentPlayer.ManaPool[color]</span>
                        </span>
                    }
                }
            </div>
        }
        @if (State.ActivePlayer == OpponentPlayer)
        {
            <MudChip T="string" Size="Size.Small" Color="Color.Primary">Active</MudChip>
        }
    </div>

    @* Row 2: Opponent battlefield *@
    <div class="opponent-battlefield">
        <div class="battlefield-row lands-row">
            @foreach (var card in OpponentPlayer.Battlefield.Cards.Where(c => c.IsLand))
            {
                <CardDisplay Name="@card.Name"
                             ImageUrl="@card.ImageUrl"
                             Tapped="@card.IsTapped"
                             CardSize="90"
                             Clickable="@(Handler?.IsWaitingForTarget == true)"
                             IsAttacking="@(State.Combat?.Attackers.Contains(card.Id) == true)"
                             IsBlocking="@IsCardBlockingAnywhere(card.Id)"
                             Power="@card.Power"
                             Toughness="@card.Toughness"
                             DamageMarked="@card.DamageMarked"
                             OnClick="async () => await HandleOpponentCardClick(card)" />
            }
        </div>
        <div class="battlefield-row nonlands-row">
            @foreach (var card in OpponentPlayer.Battlefield.Cards.Where(c => !c.IsLand))
            {
                <CardDisplay Name="@card.Name"
                             ImageUrl="@card.ImageUrl"
                             Tapped="@card.IsTapped"
                             CardSize="90"
                             Clickable="@(Handler?.IsWaitingForTarget == true)"
                             IsAttacking="@(State.Combat?.Attackers.Contains(card.Id) == true)"
                             IsBlocking="@IsCardBlockingAnywhere(card.Id)"
                             Power="@card.Power"
                             Toughness="@card.Toughness"
                             DamageMarked="@card.DamageMarked"
                             SummoningSick="@(card.IsCreature && card.HasSummoningSickness(State.TurnNumber))"
                             OnClick="async () => await HandleOpponentCardClick(card)" />
            }
        </div>
        @if (OpponentPlayer.Battlefield.Cards.Count == 0)
        {
            <MudText Typo="Typo.caption" Class="empty-zone">Opponent Battlefield</MudText>
        }
    </div>

    @* Row 3: Phase bar + stack *@
    <div class="phase-stack-row">
        <PhaseBar CurrentPhase="@State.CurrentPhase"
                  CurrentCombatStep="@State.CombatStep"
                  TurnNumber="@State.TurnNumber"
                  ActivePlayerName="@State.ActivePlayer.Name"
                  HasPriority="@HasPriority"
                  IsWaitingForCombat="@IsWaitingForCombat"
                  IsWaitingForAttackers="@(IsLocalActive && Handler?.IsWaitingForAttackers == true)"
                  IsWaitingForBlockers="@(IsLocalDefending && Handler?.IsWaitingForBlockers == true)"
                  StackCount="@State.Stack.Count"
                  StopSettings="@_phaseStops"
                  OnPass="HandlePassOrConfirm"
                  OnSkipCombat="HandleSkipCombat"
                  OnSurrender="() => OnSurrender.InvokeAsync()" />

        <StackDisplay Stack="@State.Stack" />
    </div>

    @* Row 4: Player battlefield *@
    <div class="player-battlefield">
        <div class="battlefield-row player-creatures">
            @foreach (var card in LocalPlayer.Battlefield.Cards.Where(c => !c.IsLand))
            {
                var isEligibleAttacker = Handler?.IsWaitingForAttackers == true && IsLocalActive
                    && Handler?.EligibleAttackers?.Any(c => c.Id == card.Id) == true;
                var isEligibleBlocker = Handler?.IsWaitingForBlockers == true && IsLocalDefending
                    && Handler?.EligibleBlockers?.Any(c => c.Id == card.Id) == true;
                <CardDisplay Name="@card.Name" ImageUrl="@card.ImageUrl" Tapped="@card.IsTapped"
                             Power="@card.Power" Toughness="@card.Toughness" DamageMarked="@card.DamageMarked"
                             CardSize="130"
                             Selected="@(_selectedCard?.Id == card.Id)"
                             IsAttacking="@(_selectedAttackers.Contains(card.Id) || State.Combat?.Attackers.Contains(card.Id) == true)"
                             IsBlocking="@(_blockerAssignments.ContainsKey(card.Id) || IsCardBlockingAnywhere(card.Id))"
                             Eligible="@(isEligibleAttacker || isEligibleBlocker)"
                             SummoningSick="@(card.IsCreature && card.HasSummoningSickness(State.TurnNumber))"
                             Clickable="true"
                             OnClick="async () => await HandleBattlefieldClick(card, isEligibleAttacker, isEligibleBlocker)" />
            }
        </div>
        <div class="battlefield-row player-lands">
            @foreach (var card in LocalPlayer.Battlefield.Cards.Where(c => c.IsLand))
            {
                var hasPendingMana = card.IsTapped && LocalPlayer.PendingManaTaps.Contains(card.Id);
                <div class="land-wrapper">
                    <CardDisplay Name="@card.Name" ImageUrl="@card.ImageUrl" Tapped="@card.IsTapped"
                                 CardSize="130"
                                 Selected="@(_selectedCard?.Id == card.Id)"
                                 Clickable="true"
                                 OnClick="async () => await HandleLandClick(card)" />
                    @if (hasPendingMana)
                    {
                        <button class="untap-affordance" @onclick="HandleUntapLand"
                                @onclick:stopPropagation="true"
                                title="Untap (unspent mana)">
                            &#x21B6;
                        </button>
                    }
                </div>
            }
        </div>
        @if (LocalPlayer.Battlefield.Cards.Count == 0)
        {
            <MudText Typo="Typo.caption" Class="empty-zone">Battlefield</MudText>
        }
    </div>

    @* Row 5: Player info bar *@
    <div class="player-info-bar">
        <MudText Typo="Typo.subtitle2">@LocalPlayer.Name</MudText>
        <MudChip T="string" Size="Size.Small" Color="Color.Error">@LocalPlayer.Life HP</MudChip>
        @if (IsLocalActive)
        {
            <MudChip T="string" Size="Size.Small" Color="Color.Primary">Active</MudChip>
        }
        @if (LocalPlayer.ManaPool?.Total > 0)
        {
            <div class="mana-pool-display">
                @foreach (var (color, symbol) in ManaSymbols)
                {
                    @if (LocalPlayer.ManaPool[color] > 0)
                    {
                        <span class="mana-entry">
                            <img src="https://svgs.scryfall.io/card-symbols/@(symbol).svg"
                                 alt="@color" class="mana-symbol" />
                            <span class="mana-count">@LocalPlayer.ManaPool[color]</span>
                        </span>
                    }
                }
            </div>
        }
        <MudChip T="string" Size="Size.Small" Color="Color.Default">Grave: @LocalPlayer.Graveyard.Cards.Count</MudChip>
        <MudChip T="string" Size="Size.Small" Color="Color.Default">Exile: @LocalPlayer.Exile.Cards.Count</MudChip>
        <MudChip T="string" Size="Size.Small" Color="Color.Default">Lib: @LocalPlayer.Library.Count</MudChip>
    </div>

    @* Row 6: Player hand *@
    <div class="player-hand">
        @foreach (var card in LocalPlayer.Hand.Cards)
        {
            <CardDisplay Name="@card.Name" ImageUrl="@card.ImageUrl"
                         CardSize="130"
                         Selected="@(_selectedCard?.Id == card.Id)"
                         Clickable="true"
                         OnClick="async () => await HandleHandClick(card)" />
        }
        @if (LocalPlayer.Hand.Cards.Count == 0)
        {
            <MudText Typo="Typo.caption" Class="empty-zone">Hand (empty)</MudText>
        }
    </div>

    @* Prompt overlays *@

    @* Action Menu (appears when card is selected) *@
    @if (_selectedCard != null && HasPriority)
    {
        <div class="prompt-overlay">
            <ActionMenu Visible="true"
                        CardName="@_selectedCard.Name"
                        CurrentZone="_selectedZone"
                        IsOwnCard="true"
                        IsTapped="@_selectedCard.IsTapped"
                        OnPlay="HandlePlay"
                        OnTapToggle="HandleTapToggle"
                        OnClose="ClearSelection" />
        </div>
    }

    @* Blocker ordering prompt *@
    @if (Handler?.IsWaitingForBlockerOrder == true && IsLocalActive && Handler?.BlockersToOrder != null)
    {
        <div class="prompt-overlay">
            <MudPaper Class="pa-3" Elevation="8">
                <MudText Typo="Typo.subtitle1">Order Blockers</MudText>
                <MudText Typo="Typo.body2" Class="mb-2">Click blockers in damage order.</MudText>
                <div class="blocker-order-list" style="display: flex; flex-wrap: wrap; gap: 4px;">
                    @foreach (var blocker in Handler.BlockersToOrder)
                    {
                        var orderIndex = _blockerOrder.IndexOf(blocker.Id);
                        <MudChip T="string" Color="@(orderIndex >= 0 ? Color.Primary : Color.Default)"
                                 OnClick="@(() => AddToBlockerOrder(blocker.Id))">
                            @if (orderIndex >= 0) { @($"#{orderIndex + 1} ") }
                            @blocker.Name (@blocker.Power/@blocker.Toughness)
                        </MudChip>
                    }
                </div>
                <MudButton Variant="Variant.Filled" Color="Color.Primary" Class="mt-2"
                           OnClick="ConfirmBlockerOrder">Confirm Order</MudButton>
            </MudPaper>
        </div>
    }

    @* Target picker *@
    @if (Handler?.IsWaitingForTarget == true && Handler?.EligibleTargets != null)
    {
        <div class="prompt-overlay">
            <MudPaper Class="pa-2" Outlined="true" Style="background-color: rgba(255,165,0,0.15);">
                <MudText Typo="Typo.body2" Class="mb-1">Choose target for @(Handler.TargetingSpellName):</MudText>
                @foreach (var target in Handler.EligibleTargets)
                {
                    @if (target.Id == Guid.Empty)
                    {
                        @* Player sentinel target *@
                        <MudButton Size="Size.Small" Variant="Variant.Filled" Color="Color.Error"
                                   Class="ma-1" OnClick="@(() => HandleTargetButtonClick(target))">
                            @target.Name (Player)
                        </MudButton>
                    }
                    else if (State?.Stack?.OfType<MtgDecker.Engine.StackObject>().Any(s => s.Card.Id == target.Id) == true)
                    {
                        @* Stack target (for counterspells) *@
                        <MudButton Size="Size.Small" Variant="Variant.Filled" Color="Color.Error"
                                   Class="ma-1" OnClick="@(() => HandleTargetButtonClick(target))">
                            @target.Name (Stack)
                        </MudButton>
                    }
                    else
                    {
                        <MudButton Size="Size.Small" Variant="Variant.Outlined" Color="Color.Warning"
                                   Class="ma-1" OnClick="@(() => HandleTargetButtonClick(target))">
                            @target.Name
                            @if (target.Power.HasValue) { <span> (@target.Power/@target.Toughness)</span> }
                        </MudButton>
                    }
                }
            </MudPaper>
        </div>
    }

    @* Mana color picker *@
    @if (IsWaitingForManaColor && ManaColorOptions != null)
    {
        <div class="prompt-overlay">
            <MudPaper Class="pa-2" Elevation="8">
                <MudText Typo="Typo.caption" Class="mb-1">Choose mana color:</MudText>
                <div style="display: flex; gap: 8px;">
                    @foreach (var color in ManaColorOptions)
                    {
                        var symbol = ManaSymbols.First(m => m.color == color).symbol;
                        <MudIconButton OnClick="async () => await OnManaColorChosen.InvokeAsync(color)">
                            <img src="https://svgs.scryfall.io/card-symbols/@(symbol).svg"
                                 alt="@color" style="width: 32px; height: 32px;" />
                        </MudIconButton>
                    }
                </div>
            </MudPaper>
        </div>
    }

    @* Card choice prompt (tutor) *@
    @if (Handler?.IsWaitingForCardChoice == true && Handler?.CardChoiceOptions != null)
    {
        <div class="prompt-overlay">
            <MudPaper Class="pa-3" Elevation="8">
                <MudText Typo="Typo.body2" Class="mb-2">@(Handler.CardChoicePrompt)</MudText>
                <div style="display: flex; flex-wrap: wrap; gap: 4px;">
                    @foreach (var card in Handler.CardChoiceOptions)
                    {
                        var isSelected = _selectedChoiceId == card.Id;
                        <div style="cursor: pointer; @(isSelected ? "outline: 3px solid #C69B3C; border-radius: 8px;" : "")"
                             @onclick="() => ToggleCardChoice(card.Id)">
                            <CardDisplay ImageUrl="@card.ImageUrl" Name="@card.Name" Clickable="true" />
                        </div>
                    }
                </div>
                <div style="display: flex; gap: 8px; margin-top: 8px;">
                    @if (Handler.CardChoiceOptional)
                    {
                        <MudButton Size="Size.Small" Variant="Variant.Outlined" OnClick="() => SubmitCardChoice(null)">Skip</MudButton>
                    }
                    <MudButton Size="Size.Small" Variant="Variant.Filled" Color="Color.Primary"
                               Disabled="@(_selectedChoiceId == null)" OnClick="() => SubmitCardChoice(_selectedChoiceId)">Choose</MudButton>
                </div>
            </MudPaper>
        </div>
    }

    @* Reveal cards prompt *@
    @if (Handler?.IsWaitingForRevealAck == true && Handler?.RevealedCards != null)
    {
        <div class="prompt-overlay">
            <MudPaper Class="pa-3" Elevation="8">
                <MudText Typo="Typo.body2" Class="mb-2">@(Handler.RevealPrompt)</MudText>
                <div style="display: flex; flex-wrap: wrap; gap: 4px;">
                    @foreach (var card in Handler.RevealedCards)
                    {
                        var isKept = Handler.KeptCards?.Any(k => k.Id == card.Id) == true;
                        <div>
                            <CardDisplay ImageUrl="@card.ImageUrl" Name="@card.Name" Clickable="false" />
                            @if (isKept)
                            {
                                <MudChip T="string" Size="Size.Small" Color="Color.Success">To Hand</MudChip>
                            }
                        </div>
                    }
                </div>
                <MudButton Size="Size.Small" Variant="Variant.Filled" Color="Color.Primary" Class="mt-2"
                           OnClick="() => OnRevealAcknowledged.InvokeAsync()">OK</MudButton>
            </MudPaper>
        </div>
    }

    @* Blocker assignment prompt (when blocker selected, show attackers to assign to) *@
    @if (Handler?.IsWaitingForBlockers == true && IsLocalDefending && _selectedBlocker != null && Handler?.CurrentAttackers != null)
    {
        <div class="prompt-overlay">
            <MudPaper Class="pa-2" Elevation="8">
                <MudText Typo="Typo.body2" Class="mb-1">Click an attacker to assign block:</MudText>
                @foreach (var attacker in Handler.CurrentAttackers)
                {
                    <MudChip T="string" Color="Color.Error" Class="target-highlight"
                             OnClick="@(() => AssignBlockerToAttacker(attacker.Id))">
                        @attacker.Name (@attacker.Power/@attacker.Toughness)
                    </MudChip>
                }
            </MudPaper>
        </div>
    }

    @* Log toggle button *@
    <MudIconButton Icon="@Icons.Material.Filled.Article" Size="Size.Small"
                   Class="log-toggle-btn" OnClick="ToggleLog" Title="Toggle Game Log" />

    @* Log overlay *@
    @if (_showLog)
    {
        <div class="log-overlay" @onclick="ToggleLog">
            <div class="log-panel" @onclick:stopPropagation>
                <GameLogPanel GameLog="@State.GameLog" />
            </div>
        </div>
    }
</div>

@code {
    [Parameter] public GameState State { get; set; } = default!;
    [Parameter] public int PlayerSeat { get; set; }
    [Parameter] public InteractiveDecisionHandler? Handler { get; set; }
    [Parameter] public EventCallback<GameAction> OnAction { get; set; }
    [Parameter] public EventCallback OnSurrender { get; set; }
    [Parameter] public EventCallback OnUndoTap { get; set; }
    [Parameter] public bool IsGameOver { get; set; }
    [Parameter] public string? Winner { get; set; }
    [Parameter] public EventCallback<ManaColor> OnManaColorChosen { get; set; }
    [Parameter] public EventCallback<IReadOnlyList<Guid>> OnAttackersChosen { get; set; }
    [Parameter] public EventCallback<Dictionary<Guid, Guid>> OnBlockersChosen { get; set; }
    [Parameter] public EventCallback<IReadOnlyList<Guid>> OnBlockerOrderChosen { get; set; }
    [Parameter] public EventCallback<Guid?> OnCardChosen { get; set; }
    [Parameter] public EventCallback OnRevealAcknowledged { get; set; }

    private ElementReference _boardRef;
    private PhaseStopSettings _phaseStops = new();
    private bool _showLog = false;

    // Card selection state
    private GameCard? _selectedCard;
    private ZoneType _selectedZone;

    // Combat selection state
    private HashSet<Guid> _selectedAttackers = new();
    private Dictionary<Guid, Guid> _blockerAssignments = new(); // blockerId -> attackerId
    private Guid? _selectedBlocker;
    private List<Guid> _blockerOrder = new();

    // Card choice state
    private Guid? _selectedChoiceId;

    private Player LocalPlayer => PlayerSeat == 1 ? State.Player1 : State.Player2;
    private Player OpponentPlayer => PlayerSeat == 1 ? State.Player2 : State.Player1;
    private int OpponentSeat => PlayerSeat == 1 ? 2 : 1;
    private bool HasPriority => Handler?.IsWaitingForAction == true;
    private bool IsWaitingForManaColor => Handler?.IsWaitingForManaColor == true;
    private IReadOnlyList<ManaColor>? ManaColorOptions => Handler?.ManaColorOptions;
    private bool IsLocalActive => State.ActivePlayer == LocalPlayer;
    private bool IsLocalDefending => State.ActivePlayer == OpponentPlayer;
    private bool IsWaitingForCombat =>
        Handler?.IsWaitingForAttackers == true ||
        Handler?.IsWaitingForBlockers == true ||
        Handler?.IsWaitingForBlockerOrder == true;
    private bool IsWaitingForCardChoice => Handler?.IsWaitingForCardChoice == true;
    private bool IsWaitingForRevealAck => Handler?.IsWaitingForRevealAck == true;

    private void ToggleLog() => _showLog = !_showLog;

    protected override async Task OnAfterRenderAsync(bool firstRender)
    {
        if (firstRender)
        {
            await _boardRef.FocusAsync();
        }
    }

    private Task HandleKeyDown(KeyboardEventArgs e)
    {
        // No global keyboard shortcuts â€” undo is per-land via untap affordance
        return Task.CompletedTask;
    }

    // --- Pass / Combat confirm via PhaseBar ---

    private async Task HandlePassOrConfirm()
    {
        if (Handler?.IsWaitingForAttackers == true && IsLocalActive)
        {
            await OnAttackersChosen.InvokeAsync(_selectedAttackers.ToList());
            _selectedAttackers.Clear();
        }
        else if (Handler?.IsWaitingForBlockers == true && IsLocalDefending)
        {
            await OnBlockersChosen.InvokeAsync(new Dictionary<Guid, Guid>(_blockerAssignments));
            _blockerAssignments.Clear();
            _selectedBlocker = null;
        }
        else
        {
            await OnAction.InvokeAsync(GameAction.Pass(LocalPlayer.Id));
        }
    }

    private async Task HandleSkipCombat()
    {
        if (Handler?.IsWaitingForAttackers == true)
        {
            await OnAttackersChosen.InvokeAsync(new List<Guid>());
            _selectedAttackers.Clear();
        }
        else if (Handler?.IsWaitingForBlockers == true)
        {
            await OnBlockersChosen.InvokeAsync(new Dictionary<Guid, Guid>());
            _blockerAssignments.Clear();
        }
    }

    // --- Battlefield interaction ---

    private async Task HandleBattlefieldClick(GameCard card, bool isEligibleAttacker, bool isEligibleBlocker)
    {
        // If we're targeting, submit target
        if (Handler?.IsWaitingForTarget == true)
        {
            Handler.SubmitTarget(new TargetInfo(card.Id, LocalPlayer.Id, ZoneType.Battlefield));
            return;
        }

        if (isEligibleAttacker)
        {
            ToggleAttacker(card.Id);
            return;
        }

        if (isEligibleBlocker)
        {
            SelectBlocker(card.Id);
            return;
        }

        await SelectCard(card, ZoneType.Battlefield);
    }

    private async Task HandleLandClick(GameCard card)
    {
        // If we're targeting, submit target
        if (Handler?.IsWaitingForTarget == true)
        {
            Handler.SubmitTarget(new TargetInfo(card.Id, LocalPlayer.Id, ZoneType.Battlefield));
            return;
        }

        // Untapped lands with mana ability: tap for mana immediately
        if (!card.IsTapped && card.ManaAbility != null)
        {
            await OnAction.InvokeAsync(GameAction.TapCard(LocalPlayer.Id, card.Id));
            ClearSelection();
            return;
        }

        await SelectCard(card, ZoneType.Battlefield);
    }

    private async Task HandleHandClick(GameCard card)
    {
        if (!HasPriority) return;

        // If we're targeting, submit target
        if (Handler?.IsWaitingForTarget == true)
        {
            Handler.SubmitTarget(new TargetInfo(card.Id, LocalPlayer.Id, ZoneType.Hand));
            return;
        }

        await SelectCard(card, ZoneType.Hand);
    }

    private Task SelectCard(GameCard card, ZoneType zone)
    {
        if (_selectedCard?.Id == card.Id)
        {
            ClearSelection();
            return Task.CompletedTask;
        }
        _selectedCard = card;
        _selectedZone = zone;
        return Task.CompletedTask;
    }

    private void ClearSelection() { _selectedCard = null; }

    // --- Combat: Attacker selection ---

    private void ToggleAttacker(Guid cardId)
    {
        if (_selectedAttackers.Contains(cardId))
            _selectedAttackers.Remove(cardId);
        else
            _selectedAttackers.Add(cardId);
    }

    // --- Combat: Blocker selection ---

    private void SelectBlocker(Guid cardId)
    {
        if (_blockerAssignments.ContainsKey(cardId))
        {
            _blockerAssignments.Remove(cardId);
            _selectedBlocker = null;
        }
        else
        {
            _selectedBlocker = cardId;
        }
    }

    private void AssignBlockerToAttacker(Guid attackerId)
    {
        if (_selectedBlocker.HasValue)
        {
            _blockerAssignments[_selectedBlocker.Value] = attackerId;
            _selectedBlocker = null;
        }
    }

    // --- Combat: Blocker ordering ---

    private void AddToBlockerOrder(Guid blockerId)
    {
        if (!_blockerOrder.Contains(blockerId))
            _blockerOrder.Add(blockerId);
    }

    private async Task ConfirmBlockerOrder()
    {
        if (Handler?.BlockersToOrder != null)
        {
            foreach (var b in Handler.BlockersToOrder)
            {
                if (!_blockerOrder.Contains(b.Id))
                    _blockerOrder.Add(b.Id);
            }
        }
        await OnBlockerOrderChosen.InvokeAsync(_blockerOrder.ToList());
        _blockerOrder.Clear();
    }

    // --- Card actions (from ActionMenu) ---

    private async Task HandlePlay()
    {
        if (_selectedCard == null) return;
        if (_selectedCard.IsLand)
            await OnAction.InvokeAsync(GameAction.PlayCard(LocalPlayer.Id, _selectedCard.Id));
        else
            await OnAction.InvokeAsync(GameAction.CastSpell(LocalPlayer.Id, _selectedCard.Id));
        ClearSelection();
    }

    private async Task HandleTapToggle()
    {
        if (_selectedCard == null) return;
        await OnAction.InvokeAsync(GameAction.TapCard(LocalPlayer.Id, _selectedCard.Id));
        ClearSelection();
    }

    // --- Target picker ---

    private void HandleTargetButtonClick(GameCard card)
    {
        if (card.Id == Guid.Empty)
        {
            // Player sentinel target
            var playerId = card.Name == LocalPlayer.Name ? LocalPlayer.Id : OpponentPlayer.Id;
            Handler?.SubmitTarget(new TargetInfo(Guid.Empty, playerId, ZoneType.None));
        }
        else if (State?.Stack?.OfType<MtgDecker.Engine.StackObject>().Any(s => s.Card.Id == card.Id) == true)
        {
            // Stack target (for counterspells)
            var ownerId = LocalPlayer.Id; // Stack spells use controller ID from the stack object
            Handler?.SubmitTarget(new TargetInfo(card.Id, ownerId, ZoneType.Stack));
        }
        else
        {
            var ownerId = LocalPlayer.Battlefield.Cards.Any(c => c.Id == card.Id) ? LocalPlayer.Id : OpponentPlayer.Id;
            Handler?.SubmitTarget(new TargetInfo(card.Id, ownerId, ZoneType.Battlefield));
        }
    }

    private Task HandleOpponentCardClick(GameCard card)
    {
        if (Handler?.IsWaitingForTarget == true)
            Handler.SubmitTarget(new TargetInfo(card.Id, OpponentPlayer.Id, ZoneType.Battlefield));
        return Task.CompletedTask;
    }

    // --- Card choice (tutor) ---

    private void ToggleCardChoice(Guid cardId) => _selectedChoiceId = _selectedChoiceId == cardId ? null : cardId;

    private async Task SubmitCardChoice(Guid? cardId)
    {
        _selectedChoiceId = null;
        await OnCardChosen.InvokeAsync(cardId);
    }

    // --- Untap (pending mana) ---

    private async Task HandleUntapLand()
    {
        await OnUndoTap.InvokeAsync();
    }

    // --- Helpers ---

    private bool IsCardBlockingAnywhere(Guid cardId) =>
        State.Combat?.Attackers.Any(a => State.Combat.GetBlockers(a).Contains(cardId)) == true;

    private static readonly (ManaColor color, string symbol)[] ManaSymbols =
    [
        (ManaColor.White, "W"), (ManaColor.Blue, "U"), (ManaColor.Black, "B"),
        (ManaColor.Red, "R"), (ManaColor.Green, "G"), (ManaColor.Colorless, "C")
    ];
}
