@using MtgDecker.Engine
@using MtgDecker.Engine.Enums
@using MtgDecker.Engine.Mana
@namespace MtgDecker.Web.Components.Pages.Game

<div class="player-zone @(IsOpponent ? "opponent" : "local")">
    <div class="zone-header">
        <MudText Typo="Typo.subtitle2">@PlayerName</MudText>

        @* Life counter *@
        <div style="display: flex; align-items: center; gap: 4px; margin-left: 12px;">
            <MudIconButton Icon="@Icons.Material.Filled.Remove" Size="Size.Small"
                           OnClick="() => OnLifeAdjust.InvokeAsync(-1)" />
            @if (_editingLife)
            {
                <div @onkeydown:stopPropagation>
                    <MudTextField T="string" @bind-Value="_lifeDelta" Immediate="true"
                                  Style="width: 60px;" Variant="Variant.Outlined" Margin="Margin.Dense"
                                  OnKeyDown="HandleLifeKeyDown"
                                  AutoFocus="true" />
                </div>
            }
            else
            {
                <MudChip T="string" Size="Size.Small" Color="Color.Error"
                         Style="cursor: pointer; min-width: 40px; justify-content: center;"
                         OnClick="StartEditLife">@Life</MudChip>
            }
            <MudIconButton Icon="@Icons.Material.Filled.Add" Size="Size.Small"
                           OnClick="() => OnLifeAdjust.InvokeAsync(1)" />
        </div>

        @if (IsActivePlayer)
        {
            <MudChip T="string" Size="Size.Small" Color="Color.Primary">Active</MudChip>
        }

        <MudText Typo="Typo.caption" Class="ml-2" Style="opacity: 0.7;">
            Library: @LibraryCount
        </MudText>
        <MudIconButton Icon="@Icons.Material.Filled.PostAdd" Size="Size.Small"
                       Title="Draw a card"
                       Disabled="@(LibraryCount == 0)"
                       OnClick="() => OnDrawCard.InvokeAsync()" />
        @if (ManaPool != null && ManaPool.Total > 0)
        {
            <div class="mana-pool-display">
                @foreach (var (color, symbol) in ManaOrder)
                {
                    @if (ManaPool[color] > 0)
                    {
                        <span class="mana-entry">
                            <img src="https://svgs.scryfall.io/card-symbols/@(symbol).svg"
                                 alt="@color" class="mana-symbol" />
                            <span class="mana-count">@ManaPool[color]</span>
                        </span>
                    }
                }
            </div>
        }
    </div>

    @* Attacker declaration prompt *@
    @if (IsWaitingForAttackers && !IsOpponent)
    {
        <div class="combat-prompt">
            <MudText Typo="Typo.subtitle1">Declare Attackers</MudText>
            <MudText Typo="Typo.body2" Class="mb-2">Click creatures to attack with, then confirm.</MudText>
            <MudButtonGroup>
                <MudButton Variant="Variant.Filled" Color="Color.Error" OnClick="ConfirmAttackers"
                           Disabled="@(_selectedAttackers.Count == 0)">
                    Attack (@_selectedAttackers.Count)
                </MudButton>
                <MudButton Variant="Variant.Outlined" OnClick="SkipAttack">Skip</MudButton>
            </MudButtonGroup>
        </div>
    }

    @* Blocker declaration prompt *@
    @if (IsWaitingForBlockers && !IsOpponent)
    {
        <div class="combat-prompt blocker-prompt">
            <MudText Typo="Typo.subtitle1">Declare Blockers</MudText>
            <MudText Typo="Typo.body2" Class="mb-2">
                @if (_selectedBlocker == null)
                {
                    @("Click a creature to block with, then click an attacker to assign it.")
                }
                else
                {
                    @("Now click an attacking creature to block.")
                }
            </MudText>

            @if (CurrentAttackers != null)
            {
                <div class="attacker-targets">
                    <MudText Typo="Typo.caption">Attackers:</MudText>
                    @foreach (var attacker in CurrentAttackers)
                    {
                        <MudChip T="string" Color="Color.Error"
                                 OnClick="@(() => AssignBlockerToAttacker(attacker.Id))"
                                 Class="@(_selectedBlocker != null ? "target-highlight" : "")">
                            @attacker.Name (@attacker.Power/@attacker.Toughness)
                        </MudChip>
                    }
                </div>
            }

            <MudButtonGroup Class="mt-2">
                <MudButton Variant="Variant.Filled" Color="Color.Primary" OnClick="ConfirmBlockers">
                    Confirm Blocks (@_blockerAssignments.Count)
                </MudButton>
                <MudButton Variant="Variant.Outlined" OnClick="SkipBlocking">No Blocks</MudButton>
            </MudButtonGroup>
        </div>
    }

    @* Blocker ordering prompt *@
    @if (IsWaitingForBlockerOrder && !IsOpponent && BlockersToOrder != null)
    {
        <div class="combat-prompt">
            <MudText Typo="Typo.subtitle1">Order Blockers</MudText>
            <MudText Typo="Typo.body2" Class="mb-2">Click blockers in damage order (first to receive damage first).</MudText>

            <div class="blocker-order-list">
                @foreach (var blocker in BlockersToOrder)
                {
                    var orderIndex = _blockerOrder.IndexOf(blocker.Id);
                    <MudChip T="string" Color="@(orderIndex >= 0 ? Color.Primary : Color.Default)"
                             OnClick="@(() => AddToBlockerOrder(blocker.Id))">
                        @if (orderIndex >= 0) { @($"#{orderIndex + 1} ") }
                        @blocker.Name (@blocker.Power/@blocker.Toughness)
                    </MudChip>
                }
            </div>

            <MudButton Variant="Variant.Filled" Color="Color.Primary" OnClick="ConfirmBlockerOrder" Class="mt-2">
                Confirm Order
            </MudButton>
        </div>
    }

    @* Card choice prompt (tutor effects) *@
    @if (IsWaitingForCardChoice && CardChoiceOptions != null && !IsOpponent)
    {
        <div class="card-choice-prompt">
            <MudText Typo="Typo.body2" Class="mb-2">@CardChoicePrompt</MudText>
            <div class="card-choice-grid">
                @foreach (var card in CardChoiceOptions)
                {
                    var isSelected = _selectedChoiceId == card.Id;
                    <div class="card-choice-item @(isSelected ? "selected" : "")"
                         @onclick="() => ToggleCardChoice(card.Id)">
                        <CardDisplay ImageUrl="@card.ImageUrl" Name="@card.Name" Clickable="true" />
                    </div>
                }
            </div>
            <div class="card-choice-actions">
                @if (CardChoiceOptional)
                {
                    <MudButton Size="Size.Small" Variant="Variant.Outlined" OnClick="() => SubmitCardChoice(null)">Skip</MudButton>
                }
                <MudButton Size="Size.Small" Variant="Variant.Filled" Color="Color.Primary"
                           Disabled="@(_selectedChoiceId == null)" OnClick="() => SubmitCardChoice(_selectedChoiceId)">Choose</MudButton>
            </div>
        </div>
    }

    @* Reveal cards prompt (Ringleader effects) *@
    @if (IsWaitingForRevealAck && RevealedCards != null && !IsOpponent)
    {
        <div class="reveal-prompt">
            <MudText Typo="Typo.body2" Class="mb-2">@RevealPrompt</MudText>
            <div class="card-choice-grid">
                @foreach (var card in RevealedCards)
                {
                    var isKept = KeptCards?.Any(k => k.Id == card.Id) == true;
                    <div class="card-choice-item @(isKept ? "kept" : "not-kept")">
                        <CardDisplay ImageUrl="@card.ImageUrl" Name="@card.Name" Clickable="false" />
                        @if (isKept)
                        {
                            <MudChip T="string" Size="Size.Small" Color="Color.Success">To Hand</MudChip>
                        }
                    </div>
                }
            </div>
            <MudButton Size="Size.Small" Variant="Variant.Filled" Color="Color.Primary" Class="mt-2"
                       OnClick="AcknowledgeReveal">OK</MudButton>
        </div>
    }

    @* Battlefield *@
    <div class="zone battlefield">
        @foreach (var card in Battlefield)
        {
            var isEligibleAttacker = IsWaitingForAttackers && EligibleAttackers?.Any(c => c.Id == card.Id) == true;
            var isEligibleBlocker = IsWaitingForBlockers && EligibleBlockers?.Any(c => c.Id == card.Id) == true;
            <div style="position: relative; display: inline-block;">
                <CardDisplay Name="@card.Name"
                             ImageUrl="@card.ImageUrl"
                             Tapped="@card.IsTapped"
                             Selected="@(SelectedCard?.Id == card.Id)"
                             Power="@card.Power"
                             Toughness="@card.Toughness"
                             DamageMarked="@card.DamageMarked"
                             IsAttacking="@(_selectedAttackers.Contains(card.Id) || CombatState?.Attackers.Contains(card.Id) == true)"
                             IsBlocking="@(_blockerAssignments.ContainsKey(card.Id) || IsCardBlocking(card.Id))"
                             Clickable="true"
                             OnClick="async () => await HandleBattlefieldClick(card, isEligibleAttacker, isEligibleBlocker)" />
            </div>
        }
        @if (Battlefield.Count == 0)
        {
            <MudText Typo="Typo.caption" Class="empty-zone">Battlefield</MudText>
        }
    </div>

    @* Hand *@
    <div class="zone hand">
        @if (IsOpponent)
        {
            @for (int i = 0; i < Hand.Count; i++)
            {
                var index = i;
                <CardDisplay Name="Card" IsBack="true" Clickable="@CanAct"
                             OnClick="async () => await SelectCard(Hand[index], ZoneType.Hand)" />
            }
        }
        else
        {
            @foreach (var card in Hand)
            {
                <CardDisplay Name="@card.Name"
                             ImageUrl="@card.ImageUrl"
                             Selected="@(SelectedCard?.Id == card.Id)"
                             OnClick="async () => await SelectCard(card, ZoneType.Hand)" />
            }
        }
        @if (Hand.Count == 0)
        {
            <MudText Typo="Typo.caption" Class="empty-zone">Hand (empty)</MudText>
        }
        else if (IsOpponent)
        {
            <MudText Typo="Typo.caption" Class="ml-2">@Hand.Count cards</MudText>
        }
    </div>

    @* Graveyard *@
    <div class="zone graveyard">
        <MudText Typo="Typo.caption">Graveyard (@Graveyard.Count)</MudText>
        @if (Graveyard.Count > 0)
        {
            <CardDisplay Name="@Graveyard[^1].Name"
                         ImageUrl="@Graveyard[^1].ImageUrl"
                         Selected="@(SelectedCard?.Id == Graveyard[^1].Id)"
                         OnClick="async () => await SelectCard(Graveyard[^1], ZoneType.Graveyard)" />
        }
    </div>

    @* Exile *@
    <div class="zone exile">
        <MudText Typo="Typo.caption">Exile (@Exile.Count)</MudText>
        @if (Exile.Count > 0)
        {
            <CardDisplay Name="@Exile[^1].Name"
                         ImageUrl="@Exile[^1].ImageUrl"
                         Selected="@(SelectedCard?.Id == Exile[^1].Id)"
                         OnClick="async () => await SelectCard(Exile[^1], ZoneType.Exile)" />
        }
    </div>

    @* Action Menu â€” positioned relative to selected card's zone *@
    @if (SelectedCard != null)
    {
        <div style="position: relative; display: inline-block;">
            <ActionMenu Visible="true"
                        CardName="@SelectedCard.Name"
                        CurrentZone="_selectedZone"
                        IsOwnCard="@(!IsOpponent)"
                        IsTapped="@SelectedCard.IsTapped"
                        OnPlay="HandlePlay"
                        OnTapToggle="HandleTapToggle"
                        OnMoveTo="HandleMoveTo"
                        OnClose="ClearSelection" />
        </div>
    }

    @if (IsWaitingForTarget && EligibleTargets != null && !IsOpponent)
    {
        <div class="target-picker">
            <MudPaper Class="pa-2 my-1" Outlined="true" Style="background-color: rgba(255,165,0,0.15);">
                <MudText Typo="Typo.body2" Class="mb-1">Choose target for @TargetingSpellName:</MudText>
                @foreach (var target in EligibleTargets)
                {
                    <MudButton Size="Size.Small" Variant="Variant.Outlined" Color="Color.Warning"
                               Class="ma-1" OnClick="@(() => SelectTarget(target))">
                        @target.Name
                        @if (target.Power.HasValue)
                        {
                            <span> (@target.Power/@target.Toughness)</span>
                        }
                    </MudButton>
                }
            </MudPaper>
        </div>
    }

    @if (IsWaitingForManaColor && ManaColorOptions != null && !IsOpponent)
    {
        <div class="mana-color-picker">
            <MudText Typo="Typo.caption" Class="mb-1">Choose mana color:</MudText>
            <div class="mana-choice-buttons">
                @foreach (var color in ManaColorOptions)
                {
                    var symbol = ManaOrder.First(m => m.color == color).symbol;
                    <MudIconButton Class="mana-choice-btn"
                                   OnClick="async () => await OnManaColorChosen.InvokeAsync(color)">
                        <img src="https://svgs.scryfall.io/card-symbols/@(symbol).svg"
                             alt="@color" style="width: 32px; height: 32px;" />
                    </MudIconButton>
                }
            </div>
        </div>
    }
</div>

@code {
    [Parameter] public string PlayerName { get; set; } = "";
    [Parameter] public IReadOnlyList<GameCard> Battlefield { get; set; } = Array.Empty<GameCard>();
    [Parameter] public IReadOnlyList<GameCard> Hand { get; set; } = Array.Empty<GameCard>();
    [Parameter] public IReadOnlyList<GameCard> Graveyard { get; set; } = Array.Empty<GameCard>();
    [Parameter] public int Life { get; set; }
    [Parameter] public int LibraryCount { get; set; }
    [Parameter] public IReadOnlyList<GameCard> Exile { get; set; } = Array.Empty<GameCard>();
    [Parameter] public EventCallback<int> OnLifeAdjust { get; set; }
    [Parameter] public EventCallback OnDrawCard { get; set; }
    [Parameter] public bool IsOpponent { get; set; }
    [Parameter] public bool IsActivePlayer { get; set; }
    [Parameter] public bool CanAct { get; set; }
    [Parameter] public Guid PlayerId { get; set; }
    [Parameter] public EventCallback<GameAction> OnAction { get; set; }
    [Parameter] public ManaPool? ManaPool { get; set; }
    [Parameter] public bool IsWaitingForManaColor { get; set; }
    [Parameter] public IReadOnlyList<ManaColor>? ManaColorOptions { get; set; }
    [Parameter] public EventCallback<ManaColor> OnManaColorChosen { get; set; }

    // Trigger effect parameters
    [Parameter] public bool IsWaitingForCardChoice { get; set; }
    [Parameter] public IReadOnlyList<GameCard>? CardChoiceOptions { get; set; }
    [Parameter] public string? CardChoicePrompt { get; set; }
    [Parameter] public bool CardChoiceOptional { get; set; }
    [Parameter] public EventCallback<Guid?> OnCardChosen { get; set; }
    [Parameter] public bool IsWaitingForRevealAck { get; set; }
    [Parameter] public IReadOnlyList<GameCard>? RevealedCards { get; set; }
    [Parameter] public IReadOnlyList<GameCard>? KeptCards { get; set; }
    [Parameter] public string? RevealPrompt { get; set; }
    [Parameter] public EventCallback OnRevealAcknowledged { get; set; }

    // Combat parameters
    [Parameter] public bool IsWaitingForAttackers { get; set; }
    [Parameter] public IReadOnlyList<GameCard>? EligibleAttackers { get; set; }
    [Parameter] public EventCallback<IReadOnlyList<Guid>> OnAttackersChosen { get; set; }
    [Parameter] public CombatState? CombatState { get; set; }
    [Parameter] public bool IsWaitingForBlockers { get; set; }
    [Parameter] public IReadOnlyList<GameCard>? EligibleBlockers { get; set; }
    [Parameter] public IReadOnlyList<GameCard>? CurrentAttackers { get; set; }
    [Parameter] public EventCallback<Dictionary<Guid, Guid>> OnBlockersChosen { get; set; }
    [Parameter] public bool IsWaitingForBlockerOrder { get; set; }
    [Parameter] public Guid? OrderingAttackerId { get; set; }
    [Parameter] public IReadOnlyList<GameCard>? BlockersToOrder { get; set; }
    [Parameter] public EventCallback<IReadOnlyList<Guid>> OnBlockerOrderChosen { get; set; }

    // Target picker parameters
    [Parameter] public bool IsWaitingForTarget { get; set; }
    [Parameter] public string? TargetingSpellName { get; set; }
    [Parameter] public IReadOnlyList<GameCard>? EligibleTargets { get; set; }
    [Parameter] public EventCallback<TargetInfo> OnTargetSelected { get; set; }
    [Parameter] public Guid OpponentId { get; set; }

    private GameCard? SelectedCard;
    private ZoneType _selectedZone;
    private bool _editingLife;
    private string _lifeDelta = "";

    // Combat selection state
    private HashSet<Guid> _selectedAttackers = new();
    private Dictionary<Guid, Guid> _blockerAssignments = new(); // blockerId -> attackerId
    private Guid? _selectedBlocker;
    private List<Guid> _blockerOrder = new();

    private async Task HandleBattlefieldClick(GameCard card, bool isEligibleAttacker, bool isEligibleBlocker)
    {
        if (IsWaitingForAttackers && isEligibleAttacker)
        {
            ToggleAttacker(card.Id);
            return;
        }

        if (IsWaitingForBlockers && isEligibleBlocker)
        {
            SelectBlocker(card.Id);
            return;
        }

        await SelectCard(card, ZoneType.Battlefield);
    }

    // Attacker selection
    private void ToggleAttacker(Guid cardId)
    {
        if (_selectedAttackers.Contains(cardId))
            _selectedAttackers.Remove(cardId);
        else
            _selectedAttackers.Add(cardId);
    }

    private async Task ConfirmAttackers()
    {
        await OnAttackersChosen.InvokeAsync(_selectedAttackers.ToList());
        _selectedAttackers.Clear();
    }

    private async Task SkipAttack()
    {
        await OnAttackersChosen.InvokeAsync(Array.Empty<Guid>());
        _selectedAttackers.Clear();
    }

    // Blocker selection
    private void SelectBlocker(Guid cardId)
    {
        if (_blockerAssignments.ContainsKey(cardId))
        {
            _blockerAssignments.Remove(cardId);
            _selectedBlocker = null;
        }
        else
        {
            _selectedBlocker = cardId;
        }
    }

    private void AssignBlockerToAttacker(Guid attackerId)
    {
        if (_selectedBlocker.HasValue)
        {
            _blockerAssignments[_selectedBlocker.Value] = attackerId;
            _selectedBlocker = null;
        }
    }

    private async Task ConfirmBlockers()
    {
        await OnBlockersChosen.InvokeAsync(new Dictionary<Guid, Guid>(_blockerAssignments));
        _blockerAssignments.Clear();
        _selectedBlocker = null;
    }

    private async Task SkipBlocking()
    {
        await OnBlockersChosen.InvokeAsync(new Dictionary<Guid, Guid>());
        _blockerAssignments.Clear();
        _selectedBlocker = null;
    }

    // Blocker ordering
    private void AddToBlockerOrder(Guid blockerId)
    {
        if (!_blockerOrder.Contains(blockerId))
            _blockerOrder.Add(blockerId);
    }

    private async Task ConfirmBlockerOrder()
    {
        if (BlockersToOrder != null)
        {
            foreach (var b in BlockersToOrder)
            {
                if (!_blockerOrder.Contains(b.Id))
                    _blockerOrder.Add(b.Id);
            }
        }
        await OnBlockerOrderChosen.InvokeAsync(_blockerOrder.ToList());
        _blockerOrder.Clear();
    }

    // Target selection
    private async Task SelectTarget(GameCard card)
    {
        // Check if card is on our battlefield to determine the owner
        var ownerId = Battlefield.Any(c => c.Id == card.Id) ? PlayerId : OpponentId;
        await OnTargetSelected.InvokeAsync(new TargetInfo(card.Id, ownerId, ZoneType.Battlefield));
    }

    // Card choice state
    private Guid? _selectedChoiceId;

    private void ToggleCardChoice(Guid cardId)
    {
        _selectedChoiceId = _selectedChoiceId == cardId ? null : cardId;
    }

    private async Task SubmitCardChoice(Guid? cardId)
    {
        _selectedChoiceId = null;
        await OnCardChosen.InvokeAsync(cardId);
    }

    private async Task AcknowledgeReveal()
    {
        await OnRevealAcknowledged.InvokeAsync();
    }

    private bool IsCardBlocking(Guid cardId) =>
        CombatState?.Attackers.Any(a => CombatState.GetBlockers(a).Contains(cardId)) == true;

    private async Task SelectCard(GameCard card, ZoneType zone)
    {
        if (!CanAct && !IsOpponent) return;

        if (zone == ZoneType.Battlefield && !IsOpponent && !card.IsTapped && card.IsLand && card.ManaAbility != null)
        {
            await OnAction.InvokeAsync(GameAction.TapCard(PlayerId, card.Id));
            ClearSelection();
            return;
        }

        if (SelectedCard?.Id == card.Id)
        {
            ClearSelection();
            return;
        }
        SelectedCard = card;
        _selectedZone = zone;
    }

    private async Task HandlePlay()
    {
        if (SelectedCard == null) return;

        // Lands always use PlayCard (they don't use the stack)
        // Non-lands use CastSpell (they go on the stack and require mana)
        if (SelectedCard.IsLand)
        {
            await OnAction.InvokeAsync(GameAction.PlayCard(PlayerId, SelectedCard.Id));
        }
        else
        {
            await OnAction.InvokeAsync(GameAction.CastSpell(PlayerId, SelectedCard.Id));
        }
        ClearSelection();
    }

    private async Task HandleTapToggle()
    {
        if (SelectedCard == null) return;
        var action = SelectedCard.IsTapped
            ? GameAction.UntapCard(PlayerId, SelectedCard.Id)
            : GameAction.TapCard(PlayerId, SelectedCard.Id);
        await OnAction.InvokeAsync(action);
        ClearSelection();
    }

    private async Task HandleMoveTo(ZoneType destination)
    {
        if (SelectedCard == null) return;
        await OnAction.InvokeAsync(
            GameAction.MoveCard(PlayerId, SelectedCard.Id, _selectedZone, destination));
        ClearSelection();
    }

    private void StartEditLife()
    {
        _editingLife = true;
        _lifeDelta = "";
    }

    private async Task HandleLifeKeyDown(KeyboardEventArgs e)
    {
        if (e.Key == "Enter")
        {
            if (int.TryParse(_lifeDelta, out var delta))
            {
                await OnLifeAdjust.InvokeAsync(delta);
            }
            _editingLife = false;
        }
        else if (e.Key == "Escape")
        {
            _editingLife = false;
        }
    }

    private void ClearSelection()
    {
        SelectedCard = null;
    }

    private static readonly (ManaColor color, string symbol)[] ManaOrder = new[]
    {
        (ManaColor.White, "W"),
        (ManaColor.Blue, "U"),
        (ManaColor.Black, "B"),
        (ManaColor.Red, "R"),
        (ManaColor.Green, "G"),
        (ManaColor.Colorless, "C")
    };
}
