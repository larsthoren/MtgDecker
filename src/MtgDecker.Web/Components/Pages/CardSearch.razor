@page "/cards"
@inject IMediator Mediator
@inject ISnackbar Snackbar
@inject ILogger<CardSearch> Logger

<PageTitle>Card Search - MtgDecker</PageTitle>

<MudText Typo="Typo.h4" Class="mb-4">Card Search</MudText>

<MudPaper Class="pa-4 mb-4" Elevation="1">
    <MudGrid>
        <MudItem xs="12" sm="6" md="3">
            <MudTextField @bind-Value="_searchText" Label="Card Name" Variant="Variant.Outlined"
                          Adornment="Adornment.End" AdornmentIcon="@Icons.Material.Filled.Search"
                          Immediate="false" OnKeyUp="OnSearchKeyUp" />
        </MudItem>
        <MudItem xs="12" sm="6" md="2">
            <MudSelect T="string" Value="_format" ValueChanged="OnFormatChanged" Label="Format" Variant="Variant.Outlined" Clearable="true">
                <MudSelectItem Value="@("modern")">Modern</MudSelectItem>
                <MudSelectItem Value="@("legacy")">Legacy</MudSelectItem>
                <MudSelectItem Value="@("vintage")">Vintage</MudSelectItem>
                <MudSelectItem Value="@("pauper")">Pauper</MudSelectItem>
                <MudSelectItem Value="@("commander")">Commander</MudSelectItem>
                <MudSelectItem Value="@("premodern")">Premodern</MudSelectItem>
            </MudSelect>
        </MudItem>
        <MudItem xs="12" sm="6" md="2">
            <MudSelect T="string" Value="_rarity" ValueChanged="OnRarityChanged" Label="Rarity" Variant="Variant.Outlined" Clearable="true">
                <MudSelectItem Value="@("common")">Common</MudSelectItem>
                <MudSelectItem Value="@("uncommon")">Uncommon</MudSelectItem>
                <MudSelectItem Value="@("rare")">Rare</MudSelectItem>
                <MudSelectItem Value="@("mythic")">Mythic</MudSelectItem>
            </MudSelect>
        </MudItem>
        <MudItem xs="12" sm="6" md="2">
            <MudAutocomplete T="string" @bind-Value="_type" Label="Type" Variant="Variant.Outlined"
                             SearchFunc="SearchTypes" Clearable="true"
                             Placeholder="e.g. Creature" DebounceInterval="300"
                             HelperText="Type 2+ chars to search" />
        </MudItem>
        <MudItem xs="12" sm="6" md="2">
            <MudAutocomplete T="MtgDecker.Application.Cards.SetInfo" @bind-Value="_selectedSet"
                             Label="Set" Variant="Variant.Outlined"
                             SearchFunc="SearchSets" ToStringFunc="@(s => s == null ? "" : $"{s.SetName} ({s.SetCode.ToUpperInvariant()})")"
                             Clearable="true" Placeholder="e.g. Zendikar" DebounceInterval="300"
                             HelperText="Type 2+ chars to search" />
        </MudItem>
        <MudItem xs="12" sm="6" md="1" Class="d-flex align-end">
            <MudIconButton Icon="@Icons.Material.Filled.Search" Color="Color.Primary"
                           Variant="Variant.Filled" OnClick="SearchCards" />
        </MudItem>
    </MudGrid>

    <MudStack Row="true" Class="mt-3" AlignItems="AlignItems.Center">
        <MudText Typo="Typo.body2" Class="mr-2">Colors:</MudText>
        @foreach (var color in _colorOptions)
        {
            <MudCheckBox @bind-Value="color.Selected" Label="@color.Label" Color="Color.Primary" Dense="true" />
        }
        <MudSpacer />
        <MudText Typo="Typo.body2" Class="mr-2">CMC:</MudText>
        <MudNumericField @bind-Value="_minCmc" Label="Min" Variant="Variant.Outlined"
                         Min="0" Max="20" Style="width: 80px;" />
        <MudNumericField @bind-Value="_maxCmc" Label="Max" Variant="Variant.Outlined"
                         Min="0" Max="20" Style="width: 80px;" />
    </MudStack>
</MudPaper>

<MudStack Row="true" Class="mb-3" Justify="Justify.SpaceBetween" AlignItems="AlignItems.Center">
    <MudText Typo="Typo.body2">
        @if (_totalCount > 0)
        {
            @($"{_totalCount} results found (page {_page} of {(int)Math.Ceiling((double)_totalCount / _pageSize)})")
        }
        else if (_hasSearched && !_loading)
        {
            @("No results found. Try adjusting your search filters.")
        }
    </MudText>
    <MudToggleIconButton @bind-Toggled="_gridView"
                         Icon="@Icons.Material.Filled.ViewList"
                         ToggledIcon="@Icons.Material.Filled.GridView"
                         />
</MudStack>

@if (_loading)
{
    <MudProgressLinear Color="Color.Primary" Indeterminate="true" Class="mb-4" />
}

@if (_gridView)
{
    <MudGrid>
        @foreach (var card in _cards)
        {
            <MudItem xs="6" sm="4" md="3" lg="2">
                <div class="cursor-pointer" @onclick="() => ShowCardDetail(card)">
                    @if (!string.IsNullOrEmpty(card.ImageUri))
                    {
                        <img src="@card.ImageUri" alt="@card.Name" loading="lazy"
                             style="width: 100%; border-radius: 8px; display: block;" />
                    }
                    else
                    {
                        <MudPaper Style="aspect-ratio: 5/7;" Class="d-flex align-center justify-center rounded-lg">
                            <MudText Typo="Typo.body2" Align="Align.Center">@card.Name</MudText>
                        </MudPaper>
                    }
                    @if (card.PriceUsd.HasValue)
                    {
                        <MudText Typo="Typo.caption" Align="Align.Center" Class="mt-1">
                            $@card.PriceUsd.Value.ToString("F2", CultureInfo.InvariantCulture)
                        </MudText>
                    }
                </div>
            </MudItem>
        }
    </MudGrid>
}
else
{
    <MudDataGrid T="MtgDecker.Domain.Entities.Card" Items="@_cards" Dense="true" Hover="true" RowClick="@(e => ShowCardDetail(e.Item))">
        <Columns>
            <PropertyColumn Property="x => x.Name" Title="Name" />
            <PropertyColumn Property="x => x.ManaCost" Title="Mana" />
            <PropertyColumn Property="x => x.TypeLine" Title="Type" />
            <PropertyColumn Property="x => x.Rarity" Title="Rarity" />
            <PropertyColumn Property="x => x.SetCode" Title="Set" />
            <TemplateColumn Title="Price">
                <CellTemplate>
                    @if (context.Item.PriceUsd.HasValue)
                    {
                        @($"${context.Item.PriceUsd.Value.ToString("F2", CultureInfo.InvariantCulture)}")
                    }
                </CellTemplate>
            </TemplateColumn>
        </Columns>
    </MudDataGrid>
}

@if (_totalCount > _pageSize)
{
    <MudPagination Class="mt-4 d-flex justify-center"
                   Count="@((int)Math.Ceiling((double)_totalCount / _pageSize))"
                   Selected="_page"
                   SelectedChanged="OnPageChanged" />
}

@code {
    private List<MtgDecker.Domain.Entities.Card> _cards = new();
    private string? _searchText;
    private string? _format;
    private string? _rarity;
    private string? _type;
    private MtgDecker.Application.Cards.SetInfo? _selectedSet;
    private double? _minCmc;
    private double? _maxCmc;
    private bool _gridView = true;
    private bool _loading;
    private bool _hasSearched;
    private int _page = 1;
    private int _pageSize = 24;
    private int _totalCount;

    private List<ColorOption> _colorOptions = new()
    {
        new("W", "White"),
        new("U", "Blue"),
        new("B", "Black"),
        new("R", "Red"),
        new("G", "Green")
    };

    private async Task OnSearchKeyUp(KeyboardEventArgs e)
    {
        if (e.Key == "Enter")
            await SearchCards();
    }

    private async Task OnFormatChanged(string? value)
    {
        _format = value;
        if (_hasSearched) await SearchCards();
    }

    private async Task OnRarityChanged(string? value)
    {
        _rarity = value;
        if (_hasSearched) await SearchCards();
    }

    private async Task SearchCards()
    {
        try
        {
            _loading = true;
            _page = 1;
            await LoadCards();
        }
        catch (OperationCanceledException) { }
        catch (Exception ex)
        {
            Logger.LogWarning(ex, "Failed to search cards");
            Snackbar.Add("Failed to search cards. Please try again.", Severity.Error);
        }
        finally
        {
            _loading = false;
        }
    }

    private async Task OnPageChanged(int page)
    {
        try
        {
            _page = page;
            _loading = true;
            await LoadCards();
        }
        catch (OperationCanceledException) { }
        catch (Exception ex)
        {
            Logger.LogWarning(ex, "Failed to load page {Page}", page);
            Snackbar.Add("Failed to load page. Please try again.", Severity.Error);
        }
        finally
        {
            _loading = false;
        }
    }

    private async Task LoadCards()
    {
        var selectedColors = _colorOptions.Where(c => c.Selected).Select(c => c.Code).ToList();

        var filter = new MtgDecker.Application.Interfaces.CardSearchFilter
        {
            SearchText = _searchText,
            Format = _format,
            Colors = selectedColors.Count > 0 ? selectedColors : null,
            Type = _type,
            MinCmc = _minCmc,
            MaxCmc = _maxCmc,
            Rarity = _rarity,
            SetCode = _selectedSet?.SetCode,
            Page = _page,
            PageSize = _pageSize
        };

        var result = await Mediator.Send(new MtgDecker.Application.Cards.SearchCardsQuery(filter));
        _cards = result.Cards;
        _totalCount = result.TotalCount;
        _hasSearched = true;
    }

    private async Task<IEnumerable<string>> SearchTypes(string value, CancellationToken ct)
    {
        if (string.IsNullOrWhiteSpace(value) || value.Length < 2)
            return Array.Empty<string>();

        return await Mediator.Send(new MtgDecker.Application.Cards.SearchTypeNamesQuery(value), ct);
    }

    private async Task<IEnumerable<MtgDecker.Application.Cards.SetInfo>> SearchSets(string value, CancellationToken ct)
    {
        if (string.IsNullOrWhiteSpace(value) || value.Length < 2)
            return Array.Empty<MtgDecker.Application.Cards.SetInfo>();

        return await Mediator.Send(new MtgDecker.Application.Cards.SearchSetNamesQuery(value), ct);
    }

    private async Task ShowCardDetail(MtgDecker.Domain.Entities.Card card)
    {
        var parameters = new DialogParameters<CardDetailDialog>
        {
            { x => x.Card, card }
        };

        var options = new DialogOptions
        {
            MaxWidth = MaxWidth.Medium,
            FullWidth = true,
            CloseOnEscapeKey = true
        };

        await DialogService.ShowAsync<CardDetailDialog>(card.Name, parameters, options);
    }

    [Inject] private IDialogService DialogService { get; set; } = default!;

    private class ColorOption
    {
        public string Code { get; set; }
        public string Label { get; set; }
        public bool Selected { get; set; }

        public ColorOption(string code, string label)
        {
            Code = code;
            Label = label;
        }
    }
}
